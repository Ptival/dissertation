\subsubsection*{Term-directed term repair algorithm}

The algorithm for $\repairTermThreeOp$ is directed by the syntax of the term
being repaired.

For repairing variables (Rule \rulename{\UTRVar}) and function applications
(Rule \rulename{\UTRApp}), we use another helper, $\repairArgsOp$, to compute
the diff.  First, we syntactically extract as many application nodes as
possible, building a list of the arguments, until the function symbol (in the
case of a variable, this corresponds to an empty list of arguments).  Once we
lookup the type diff for the function symbol (resp. $\delta_{\tau_v}$ and
$\delta_{\tau_f}$), we can start producing the output diff.  An example will be
illustrative of the $\repairArgsOp$ algorithm: consider the case where a
function $f$ had type $(A \rightarrow C)$ and undergoes the transformation
$\MathModPi{\MathSame}{\MathSame}{(\MathInsPi{B}{\_}{\MathSame})}$, yielding the
type $(A \rightarrow B \rightarrow C)$.  Suppose the original code contains a
call to $f$, for instance $(f\ a)$.  A repaired version of this call would look
like $(f\ a\ (\MathAnnot{\MathHole}{B}))$.  This means the repair diff should be
$(\MathInsApp{(\MathModApp{\MathSame}{\MathSame})}{(\MathAnnot{\MathHole}{B})})$.
Notice how the outermost term modification, $\MathInsAppOp$, corresponds to the
innermost type modification $\MathInsPiOp$.  This is not surprising: a function
$g$ whose type is $(A \rightarrow (B \rightarrow (C \rightarrow D)))$, and its
application to arguments $(((g\ a)\ b)\ c)$, exhibit the same inversion.  For
this reason, $\repairArgsOp$ works by processing the $\Pi$-telescope type diff
(i.e. a sequence of nested $\Pi$s) from outside-in, and builds the applications
term diff from inside-out.  We omit the rules for $\repairArgsOp$ as they would
be cumbersome and not enlightening.

We also omit the rules for repairing a \coqinline{match} construct behind the
symbol $\repairBranchesOp$.  Once the discriminee is repaired, the branches must
be repaired: first, the discriminated inductive data type is identified, and its
diff is retrieved from the global environment.  From this, the list of branches
is repaired, with proper care for the binding structure of the patterns.  Our
current implementation only supports non-nested pattern matches, and proceeds by
computing a permutation from the order in which patterns appear in the program
to the order in which they appear in the inductive data type declaration.  The
process of repairing the branches is then straightforward: if a constructor was
added, a branch is added, if a constructor was removed, its branch (if any) is
removed, and modifications to constructors impact the pattern and arm of its
matching branch.  Notice that we do not support the full power of
dependently-typed elimination yet: our \coqinline{match} construct does not have
an index binding declaration or a return type annotation (respectively known as
the \coqinline{in}-clause and the \coqinline{return}-clause in \Gallina{}).

Also of note, in Rule \rulename{\UTRAnnot}, we actually retrieve type
information from the annotation, and can repair the annotated term with more
information.  In practice however, we don't expect much code to contain type
annotations.  Finally, Rule \rulename{\UTROtherwise} captures terms such as
holes, and universes, which we repair by doing nothing.

\input{chick-rules-unknown-repair}
