\subsection{Repairing programs}~\label{repair-program}

The repair algorithm for programs $\repairProgOp$ is described formally in
Figure~\ref{fig:repair-program} using the following judgment:

{
  \[
    {\turnstile
      {\denv{E}{\delta_E}}
      {\repairProg{p}{\delta_p}{\delta_p'}}
    }
  \]
}

\noindent To the left of the turnstile are the \textit{global environment} and
its diff.  The top part, $E$, is the environment in which the original program
$p$ was originally defined: a list of global term definitions , with type
$\GlobalDefinitionText$, and of global inductive data type definitions, with
type $\GlobalInductiveText$.  Each vernacular command is type-checked in such a
global typing environment, and then populates it with some additional
definitions for the subsequent commands.  The bottom part, $\delta_E$, is a diff
indicating how the global environment has been changed by the time $p$ is
reached by the repair algorithm: it accounts for whether some definitions have
been added, removed, or modified.  For instance, in our motivating example, by
the time we reach the inductive definition being modified (\coqinline{list},
becoming \coqinline{vec}), $E$ would contain the global inductive data type
definition for the type \coqinline{nat}, and $\delta_E$ would keep it intact.
After this definition has been processed, $E$ would contain, in order,
\coqinline{nat} \coqinline{list}, and $\delta_E$ would still keep the former
intact, but would register the diff turning \coqinline{list} into
\coqinline{vec}.

The repair algorithm for programs takes as input the original program $p$, and
the user-provided modification $\delta_p$.  From those, it outputs a patched
modification $\delta_p'$, that propagates the changes introduced by $\delta_E$
and $\delta_p$ to the rest of the program $p$.  The algorithm essentially folds
over the sequence of vernacular commands, propagating changes from previous
commands to subsequent ones.

The rule \rulename{\RProgMod} does the bulk of the work, dispatching the repair
of each vernacular command to the repair algorithm for vernacular commands
$\repairVernacOp$ (described in Section~\ref{repair-vernacular}).  First, the
head vernacular command $v$ is repaired (using $\repairVernacOp$), returning a
repaired diff $\delta_v'$.  Then, we want to repair the rest of the program, but
the changes made to $v$ will affect the global environment for the subsequent
commands.  For instance, in our motivating example, the vernacular command
defining the inductive type \coqinline{list} gets modified to define the
inductive type \coqinline{vec} instead: when we repair the rest of the program,
we must remember that the original program was defined in a global environment
where \coqinline{list} was defined, and that the updated program must replace it
with \coqinline{vec}.  We therefore repair the rest of the program $p$ in the
appropriate updated environment and its diff.

Note that, while the rule seems to imply that vernacular commands each add
exactly one element to the global environment, it is not the case: an inductive
data type definition adds the inductive type, all its constructors, and all its
eliminators.  For simplifying diff operations, the whole $\InductiveText$
effectively acts as a placeholder for all of those when in the global
environment.  The lookup rules, given in the Appendix~\ref{appendix}, contain
the complexity of accounting for all these global definitions arising from one
inductive data type definition.

\rulename{\RProgSameCons} simply defers to \rulename{\RProgMod}: even though it
processes unchanged commands, they might need repairs to account for changes in
upstream, accounted for in the global environment.

\begin{Rules}{fig:repair-program}{ Rules for repairing programs
($\repairProgOp$).  We use $\MathSameProg$ to indicate an identity diff for
programs, and $\MathSameVernac$ to indicate an identity diff for vernacular
commands. }

  \begin{mathpar}

    {
      \inferrule*
          [lab=R-Prog-Same-Nil]
          {  }
          {\turnstile%
            { \denv{E}{\delta_E} }
            { \repairProg{[]}{\MathSame}{\MathSame} }
          }
    }

    {
      \inferrule*
          [lab=\RProgSameCons]
          {
            {\turnstile%
              { \denv{E}{\delta_E} }
              { \repairProg{\MathCons{v}{p}}{\MathMod{\MathSameVernac}{\MathSameProg}}{\delta} }
            }
          }
          {\turnstile%
            { \denv{E}{\delta_E} }
            { \repairProg{\MathCons{v}{p}}{\MathSame}{\delta} }
          }
    }

    {
      \inferrule*
          [lab=R-Prog-Replace]
          {\turnstile%
            { \denv{E}{\delta_E} }
            { \repairProg{q}{\MathSameProg}{\delta} }
          }
          {\turnstile%
            { \denv{E}{\delta_E} }
            { \repairProg{p}{\MathReplace{q}}{\delta} }
          }
    }

    % {
    %   \inferrule*
    %       [lab=\RProgKeep]
    %       {
    %         {\turnstile
    %           { \denv{E'}{\delta_E'} }
    %           { \repairProg{\MathCons{v}{p}}{\MathMod{\MathSameVernac}{\delta_p}}{\delta} }
    %         }
    %       }
    %       {\turnstile
    %         { \denv{E}{\delta_E} }
    %         { \repairProg{\MathCons{v}{p}}{\MathKeep{\delta_p}}{\delta} }
    %       }
    % }

    {
      \inferrule*
          [lab=R-Prog-Modify]
          {
            {\turnstile%
              { \denv{E}{\delta_E} }
              { \repairVernac{v}{\delta_v}{\delta_v'} }
            }
            \and
            {\turnstile%
              { \denv{v \Cons{} E}{\MathMod{\delta_v'}{\delta_E}} }
              { \repairProg{p}{\delta_p}{\delta_p'} }
            }
          }
          {\turnstile%
            { \denv{E}{\delta_E} }
            { \repairProg{\MathCons{v}{p}}{\MathMod{\delta_v}{\delta_p}}{\MathMod{\delta_v'}{\delta_p'}} }
          }
    }

    {
      \inferrule*
          [lab=R-Prog-Drop]
          {
            {\turnstile%
              { \denv{v \Cons{} E}{\MathDrop{\delta_E}} }
              { \repairProg{p}{\delta_p}{\delta_p'} }
            }
          }
          {\turnstile%
            { \denv{E}{\delta_E} }
            { \repairProg{\MathCons{v}{p}}{\MathDrop{\delta_p}}{\MathDrop{\delta_p'}} }
          }
    }

    {
      \inferrule*
          [lab=R-Prog-Permute]
          {
            { \MathPatches{q}{\MathPermute{p}{}}{q'} }
            \and
            {\turnstile%
              { \denv{E}{\delta_E} }
              { \repairProg{q'}{\delta}{\delta'} }
            }
          }
          {\turnstile%
            { \denv{E}{\delta_E} }
            { \repairProg{q}{\MathPermute{p}{\delta}}{\MathPermute{p}{\delta'}} }
          }
    }

    \end{mathpar}

\end{Rules}
