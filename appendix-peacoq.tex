\chapter{\PeaCoq{}}~\label{appendix-peacoq}

\section{\PeaCoq{} A-B study material}~\label{appendix-peacoq-material}

In this section, we report the entire listing of exercises provided to the participants of the A-B study described in Section~\ref{peacoq-a-b-study}.

\begin{minted}[fontsize=\scriptsize]{coq}
(* The following material is derived from Software Foundations by Benjamin
Pierce et al. Their work is under the following MIT license: *)

(*
Copyright (c) 2012

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 *)

(* ###################################################################### *)
(** ** Days of the Week *)

Inductive day : Type :=
| monday : day
| tuesday : day
| wednesday : day
| thursday : day
| friday : day
| saturday : day
| sunday : day
.

Definition tomorrow (d: day) : day :=
  match d with
  | monday    => tuesday
  | tuesday   => wednesday
  | wednesday => thursday
  | thursday  => friday
  | friday    => saturday
  | saturday  => sunday
  | sunday    => monday
  end.

Theorem test_tomorrow:
  tomorrow saturday = sunday.
Proof.
  simpl. reflexivity.
Qed.

(* ###################################################### *)
(** ** Lists of Numbers *)

Inductive natlist : Type :=
| nil  : natlist
| cons : nat -> natlist -> natlist
.

Definition empty_list := nil.

Definition singleton_list := cons 42 nil.

Definition one_two_three := cons 1 (cons 2 (cons 3 nil)).

Fixpoint concat (l1 l2 : natlist) : natlist :=
  match l1 with
  | nil      => l2
  | cons h t => cons h (concat t l2)
  end.

Theorem test_concat1:
  concat (cons 1 (cons 2 nil))
         (cons 3 (cons 4 nil))
  = (cons 1 (cons 2 (cons 3 (cons 4 nil)))).
Proof.
  simpl. reflexivity.
Qed.

(* ###################################################### *)
(** * Reasoning About Lists *)

Theorem concat_nil_left : forall l : natlist,
  concat nil l = l.
Proof.
  (* FILL IN HERE *)
Qed.

Theorem concat_nil_right : forall l : natlist,
  concat l nil = l.
Proof.
  (* FILL IN HERE *)
Qed.

(* In-class exercise! *)
Theorem concat_associativity : forall l2 l1 l3 : natlist,
  concat (concat l1 l2) l3 = concat l1 (concat l2 l3).
Proof.
  (* FILL IN HERE *)
Qed.

(*
  [snoc] adds an element [v] at the end of the list [l]:
    snoc (cons 1 (cons 2 nil)) 3 = cons 1 (cons 2 (cons 3 nil))
*)
Fixpoint snoc (l: natlist) (v: nat) : natlist :=
  match l with
  | nil      => cons v nil
  | cons h t => cons h (snoc t v)
  end.

(*
  [rev] reverses a list:
    rev (cons 1 (cons 2 nil)) = cons 2 (cons 1 nil)
*)
Fixpoint rev (l: natlist) : natlist :=
  match l with
  | nil      => nil
  | cons h t => snoc (rev t) h
  end.

(* ###################################################### *)
(**
  For each theorem:
  - Discuss the statement of the theorem with your partner.
  - Once you understand it, prove the theorem.

  Every time you solve a theorem, switch who uses the keyboard/mouse.
 *)

Theorem rev_snoc : forall x l,
  rev (snoc l x) = cons x (rev l).
Proof.
  (* FILL IN HERE *)
Qed.

Theorem rev_involutive : forall l : natlist,
  rev (rev l) = l.
Proof.
  (* FILL IN HERE *)
Qed.

Theorem concat_cons_snoc : forall l1 x l2,
  concat l1 (cons x l2) = concat (snoc l1 x) l2.
Proof.
  (* FILL IN HERE *)
Qed.

(* ###################################################### *)

Module LogicExercises.

(* We now use notations from logic:
  /\   stands for the logical conjunction (AND) of two propositions
  \/   stands for the logical disjunction (OR)  of two propositions

  New tactics: left, right

  When your goal looks like [A \/ B]
  You get to pick which of [A] or [B] you will prove.
  If you believe you can prove [A], use the [left.] tactic.
  If you believe you can prove [B], use the [right.] tactic.

  Here is an example:
*)

Theorem goright_example : 0 = 1 \/ 1 = 1.
Proof. right. reflexivity.
Qed.

Theorem go_somewhere : 0 = 1 \/ (2 = 2 \/ 2 = 3).
Proof.
  (* FILL IN HERE *)
Qed.

(*
  New tactic: apply

  If you ever have a goal [G]
  And a hypothesis [H : G] or [H : X -> ... -> G]
  You can use the tactic [apply H.] to solve your goal in the former case,
  or turn your goal into subgoal(s) [X], [...] in the latter case.
*)

Theorem B_is_enough : forall A B : Prop,
  B ->
  A \/ B.
Proof.
  (* FILL IN HERE *)
Qed.

(*
  New tactic: split

  When your goal looks like [A /\ B]
  You need to prove both [A] and [B].
  The tactic [split.] lets you split your goal into these two goals.

  Here is an example:
*)

Theorem two_facts : nil = nil /\ 42 = 42.
Proof. split. reflexivity. reflexivity.
Qed.

Theorem more_facts : 1 = 2 \/ (1 = 1 /\ nil = nil).
Proof.
  (* FILL IN HERE *)
Qed.

Theorem A_and_B : forall A B : Prop,
  A ->
  B ->
  A /\ B.
Proof.
  (* FILL IN HERE *)
Qed.

End LogicExercises.

(* ###################################################### *)

Theorem snoc_concat_end : forall (l: natlist) (n: nat),
  snoc l n = concat l (cons n nil).
Proof.
  (* FILL IN HERE *)
Qed.

Theorem rev_distributes_over_concat : forall l1 l2 : natlist,
  rev (concat l1 l2) = concat (rev l2) (rev l1).
Proof.
  (* FILL IN HERE *)
Qed.

(* ###################################################### *)
(** We now introduce [map], which applies a function [f] to
    every element of a list [l].
*)

Fixpoint map (f: nat -> nat) (l: natlist) :=
  match l with
  | nil => nil
  | cons x xs => cons (f x) (map f xs)
  end.

Theorem map_commutes : forall f g l,
  (forall x, f (g x) = g (f x)) ->
  map f (map g l) = map g (map f l).
Proof.
  (* FILL IN HERE *)
Qed.

(* In this theorem, "fun x =>" introduces an anonymous function which receives
   a parameter [x] and returns the result on the right of the arrow. *)
Theorem map_fusion : forall f g l,
  map f (map g l) = map (fun x => f (g x)) l.
Proof.
  (* FILL IN HERE *)
Qed.

(* ###################################################### *)
(** We now introduce [fold], which processes a list with an
    accumulating function [f], starting from an initial value [b].
*)
Fixpoint fold (f: nat -> natlist -> natlist) (l: natlist) (b: natlist) :=
  match l with
  | nil => b
  | cons x xs => f x (fold f xs b)
  end.

Theorem fold_snoc : forall f l x b,
  fold f (snoc l x) b = fold f l (f x b).
Proof.
  (* FILL IN HERE *)
Qed.

Definition map' f l := fold (fun x fxs => cons (f x) fxs) l nil.

(* We use [Lemma] instead of [Theorem] here to indicate that this theorem may
   help you in proving the next theorem. *)
Axiom map'_unroll : forall f x xs,
  map' f (cons x xs) = cons (f x) (map' f xs).

Axiom map'_nil : forall f, map' f nil = nil.

Theorem map_map' : forall f l, map f l = map' f l.
Proof.
  (* FILL IN HERE *)
Qed.

Ltac cases H := match type of H with _ \/ _ => destruct H end.

(*
  New tactics: cases, contradiction

  When a hypothesis looks like [H : A \/ B]
  You have to prove the goal for each case, to do so, use the tactic [cases H.]
  You will get two goals as a result, one with a [A] hypothesis, one with a [B] hypothesis.

  Finally, if you ever get a hypothesis like [H : False]
  You have derived a contradiction, and you can indicate this to the system by calling
  the tactic [contradiction.], which will solve your goal.
*)

Fixpoint In n l :=
  match l with
  | nil      => False
  | cons h t => h = n \/ In n t
  end.

Theorem In_cons : forall x h l,
  In x l ->
  In x (cons h l).
Proof.
  (* FILL IN HERE *)
Qed.

(*
  New tactic: simpl in *

  Sometimes, you might want to simplify things in your hypotheses, the same way things
  can be simplified in your conclusion.
*)

Theorem In_concat_left : forall x l1 l2,
  In x l1 ->
  In x (concat l1 l2).
Proof.
  (* FILL IN HERE *)
Qed.
\end{minted}

\clearpage

\section{\PeaCoq{} A-B study post-study survey}~\label{appendix-peacoq-a-b-study}

We report the qualitative feedback obtained via a questionnaire given after the
A-B study described in Section~\ref{peacoq-a-b-study}.  We indicate participants
anonymously as $Xp_{i}$ where $X$ stands for the study group ($A$ being the
\define{control group}, $B$ being the group testing our tool), $p$ stands for a
given pair of participants, and $i$ distinguishes between the two participants
in a pair.

We report participants' answers as is: we do fix typos, but do not alter their
phrasing or grammatical structures whatsoever.

\clearpage

\noindent
\begin{tabularx}{\linewidth}{@{}cX@{}}
  \toprule
  Participant & \multicolumn{1}{c}{
    \textbf{In your own words, describe what you did today.}
  } \\ \midrule
  $A1_{1}$ & Proved several theorems in a pair using an interactive proof assistant. \\
  $A1_{2}$ & \begin{enumerate} \item Proved some set and logic and operation lemmas and theorems. \item Used a new tool to write the proofs. \end{enumerate} \\
  $A2_{1}$ & Tried to understand \Coq{} by using an entire IDE and write some proofs. \\
  $A2_{2}$ & We used a proof assistant to prove theorems about lists and their properties. \\
  $A3_{1}$ & We used the theorem prover to prove that the functions of code did what they meant to in all cases. \\
  $A3_{2}$ & Today I learned about the \Coq{} theorem proving language.  After an introduction, I worked in a pair to solve various theorems for lists of natural numbers, and maps. \\
  $A4_{1}$ & Use an automated theorem prover to prove basic facts in data structures and logic. \\
  $A4_{2}$ & We used a tool that could define predicates, types and prove various properties about them. \\
  $A5_{1}$ & We learned a little about basic proofs in \Coq{} then applied what we learned in the exercises. \\
  $A5_{2}$ & I used a proof assistant to prove several simple mathematical theorems. \\
  \bottomrule
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\linewidth}{@{}cX@{}}
  \toprule
  Participant & \multicolumn{1}{c}{
    \textbf{In your own words, describe what you did today.}
  } \\ \midrule
  $B1_{1}$ & I used a graphical tool to prove several invariants about functions/data structures in a given language (\Coq{}). \\
  $B1_{2}$ & Proved some special cases of inferences from new definitions using induction and other primitive proof techniques.  Use already proved theorems in future proofs. \\
  $B2_{1}$ & I used a programming language tool to prove various constructs. \\
  $B2_{2}$ & Proved a bunch of simple theorems about functions working on lists. \\
  $B3_{1}$ & Use \Coq{} to prove a theorem.  Reasoning the steps and select what makes sense from the options given by the tool. \\
  $B3_{2}$ & We were trying to use \PeaCoq{} to prove a bunch of theorems by exploring all the possible strategies, such as induction, transformation, simplification, etc. \\
  $B4_{1}$ & We used a graphical version of an interactive proof assistant to prove some theorems involving list operations. \\
  $B4_{2}$ & Proved some functions using \PeaCoq{}. \\
  $B5_{1}$ & We used the \PeaCoq{} web editor interface to prove theorems on pieces of code via \Coq{}.  First we were given an introduction to \Coq{} combined with a tutorial on using the tool, and then we worked in pairs on a series of example of proofs/theorems. \\
  $B5_{2}$ & I used a modified version of the \Coq{} proof assistant to prove things about lists and functions over them. \\
  \bottomrule
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\linewidth}{@{}cX@{}}
  \toprule
  Participant & \multicolumn{1}{c}{
    \textbf{What did the experience today remind you of?}
  } \\ \midrule
  $A1_{1}$ & Learning to program for the first time. Lots of brute-forcing and trying things that worked in the past to see if they would work in a new context. \\
  $A1_{2}$ & Using induction in high school/undergrad and trying to draw insights from proving the base case to apply to the general case. \\
  $A2_{1}$ & Today was quite unique but I felt like writing functional programs since I tried to prove my implementation there too. \\
  $A2_{2}$ & It reminded me of working on large code bases where certain things appear to work by magic.  Fixes/proofs were performed with little fundamental understanding. \\
  $A3_{1}$ & Taking a programming languages class, since the constructs are all the same. \\
  $A3_{2}$ & Today's experience reminded me of an intro to algorithms course. \\
  $A4_{1}$ & Proving mathematical theorems for research. \\
  $A4_{2}$ & Liquid types in Haskell.  Mathematical induction. \\
  $A5_{1}$ & Learning programming in school and proofs in math classes. \\
  $A5_{2}$ & It reminded me of pen-and-paper proofs. \\
  \bottomrule
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\linewidth}{@{}cX@{}}
  \toprule
  Participant & \multicolumn{1}{c}{
    \textbf{What did the experience today remind you of?}
  } \\ \midrule
  $B1_{1}$ & Playing a logical/exploration game. \\
  $B1_{2}$ & \begin{enumerate} \item Writing unit tests for corner cases. \item Giving a systematic proof covering all cases. \end{enumerate} \\
  $B2_{1}$ & It reminded me of safe programming techniques in the way that if we can prove that our constructs work, there shouldn't be any problems at run-time. \\
  $B2_{2}$ & Functional programming and reasoning about it. \\
  $B3_{1}$ & First time to learn formal proof stuff. \\
  $B3_{2}$ & Decision tree. \\
  $B4_{1}$ & It reminded me of a puzzle game in which you have to reach a target and can use as keys some of the facts you encounter on your way there. \\
  $B4_{2}$ & Proving technique classes. \\
  $B5_{1}$ & The \inferrule{ \text{rules} \\\\ \text{rules} \\\\ \text{rules} }{ statement } format reminded me of constructions I have seen in computer science papers that have not formally learned about.  The theorems we were proving, e.g. \safecoqinline{concat xs nil = xs}, reminded in a different/more powerful direction (but requiring manual work to prove). \\
  $B5_{2}$ & Analysis class, proving simple-seeming things about math was similarly harder than it looked. \\
  \bottomrule
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\linewidth}{@{}cX@{}}
  \toprule
  Participant & \multicolumn{1}{c}{
    \textbf{Did you understand all the proofs you completed?}
  } \\ \midrule
  $A1_{1}$ & No. \\
  $A1_{2}$ & No.  We figured out that there were some hammers which we should keep using (\safecoqinline{simpl}, \safecoqinline{reflexivity}, \safecoqinline{rewrite}).  They mostly made sense but we didn't spend time to understand the exact changes they made. \\
  $A2_{1}$ & Most of them.  Especially the last ones were quite confusing. \\
  $A2_{2}$ & Not entirely.  While I had conceptual knowledge of what was happening, I didn't understand it holistically. \\
  $A3_{1}$ & Yes. \\
  $A3_{2}$ & Yes. \\
  $A4_{1}$ & Yes. \\
  $A4_{2}$ & Yes. \\
  $A5_{1}$ & Yes. \\
  $A5_{2}$ & Yes. \\
  \bottomrule
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\linewidth}{@{}cX@{}}
  \toprule
  Participant & \multicolumn{1}{c}{
    \textbf{Did you understand all the proofs you completed?}
  } \\ \midrule
  $B1_{1}$ & Yes. \\
  $B1_{2}$ & Yes. \\
  $B2_{1}$ & Yes, the only one that I had trouble with was \safecoqinline{destruct}. \\
  $B2_{2}$ & No. \\
  $B3_{1}$ & No.  Sometimes it is magically done. \\
  $B3_{2}$ & No, but most of them. \\
  $B4_{1}$ & Yes (at least on a second closer inspection). \\
  $B4_{2}$ & No. \\
  $B5_{1}$ & For the most part.  The last exercise (\safecoqinline{In_concat_left}) had me a bit confused on how \safecoqinline{destruct} worked/what it did.  Once that clicked for me, what we were doing there made sense. \\
  $B5_{2}$ & I think so? \\
  \bottomrule
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\linewidth}{@{}cX@{}}
  \toprule
  Participant & \multicolumn{1}{c}{
    \textbf{Did you find the tool useful for achieving the tasks?}
  } \\ \midrule
  $A1_{1}$ & Error messages were mostly helpful sometimes. Sort of. Clear when something didn't work. \\
  $A1_{2}$ & Yes.  Because it would stop me from trying to use wrong rules.  Also because I could follow from one lemma to another in most cases. \\
  $A2_{1}$ & \begin{enumerate} \item Has a simple, clean UI, \item Doesn't require anything other than a browser. \end{enumerate} \\
  $A2_{2}$ & A little.  It provided confidence that the task was completed correctly. \\
  $A3_{1}$ & Yes.  I like how the right side always showed the next goal, in that it was easy to focus on one statement at a time. \\
  $A3_{2}$ & Yes, very. \\
  $A4_{1}$ & Yes, it was pretty self-explanatory.  Inline code and comments very helpful. \\
  $A4_{2}$ & Yes. \\
  $A5_{1}$ & Yes, the step by step approach was helpful to visualize how the proof was coming along.  It also helped with trial and error. \\
  $A5_{2}$ & Highlighting, previous/next were extremely useful.  The information snippets would be useful if I weren't the proof author. \\
  \bottomrule
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\linewidth}{@{}cX@{}}
  \toprule
  Participant & \multicolumn{1}{c}{
    \textbf{Did you find the tool useful for achieving the tasks?}
  } \\ \midrule
  $B1_{1}$ & The tool was very useful, specifically: \begin{enumerate} \item Highlighting the diffs was helpful to explain what each tactic does, \item Having all the options available to apply was helpful for a novice who doesn't know what the available tactics are. \end{enumerate} \\
  $B1_{2}$ & Yes. \\
  $B2_{1}$ & It definitely helped in showing the paths you could take in a proof, which is helpful if you can't think of them on the spot. \\
  $B2_{2}$ & I proved things without having to think too hard about it. \\
  $B3_{1}$ & \begin{enumerate} \item As an inexperienced learner, I even don't know how to start a proof, but the tool gives me the guidance to do this. \item After some time, when you get familiar with it, there exists some patterns to find the correct solution. \end{enumerate} \\
  $B3_{2}$ & I think it's useful.  But it is hard to say ``how'' useful it is for two reasons: \begin{enumerate} \item I'm not aware of any order tools, \item the problems are actually simple and intuitive to prove manually. \end{enumerate} \\
  $B4_{1}$ & \begin{enumerate} \item Provided a broad overview of the available options (some perhaps ``counter-intuitive'' options that I might have thought of were presented right away), \item fewer keystrokes \item visual diffs are very useful for calculating how bigger / smaller our target is. \end{enumerate} \\
  $B4_{2}$ & I wouldn't be able to achieve the tasks on my own, but that's probably because I have no idea how to prove those things. \\
  $B5_{1}$ & Yes, absolutely.  The tree interface made exploring possible tactics and seeing the results very quick and easy.  I've never actually used \Coq{} or anything like it before but with this interface I was able to get up to speed pretty quickly. \\
  $B5_{2}$ & I didn't have to already know/remember the set of options, and it was useful to get a preview of what each one would do. \\
  \bottomrule
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\linewidth}{@{}cX@{}}
  \toprule
  Participant & \multicolumn{1}{c}{
    \textbf{Do you have suggestions on how to improve the tool you used today?}
  } \\ \midrule
  $A1_{1}$ & Backing up through a \safecoqinline{Qed.} backs up the entire proof.  Would prefer to step back one tactic at a time like during the proof.  Right-hand pane sometimes not wide enough to see everything.  Primitive sub-string matching to suggest rewrites would be useful. \\
  $A1_{2}$ & \begin{enumerate} \item It should stop me from going down useless proof steps even though the rules apply. \item It should stop me from going in circles by warning (we are not sure we did that but came close). \item Difficult to translate intuition from base case to general case.  Had to use pen-and-paper at times to write small examples. \end{enumerate} \\
  $A2_{1}$ & \begin{enumerate} \item Missing some keyboard shortcuts. \item Having a pane which shows previous proofs would be quite helpful. \end{enumerate} \\
  $A2_{2}$ & I had little confidence that I understood what was happening.  Completing the same proofs later would likely result in similar trial and error.  The only thing I was learning was the sort of patterns that proofs took on.  Variable names were confusing and hard to work with. \\
  $A3_{1}$ & \safecoqinline{each} should be syntax-highlighted. \\
  $A3_{2}$ & Adding auto-complete would be nice and a command list. \\
  $A4_{1}$ & Previously proved functions were difficult to find/see when scrolling up.  I could see this being a major problem for anything complex.  Could be solved with a better interface e.g.\ in an IDE.\@Not related to the software, but there's a tendency to avoid planning and just react to results of \safecoqinline{simpl}, \safecoqinline{rewrite}, etc. \\
  $A4_{2}$ & \begin{enumerate} \item Bugs when we were using Firefox instead of Chrome.  Tool wouldn't revert steps correctly. \item Auto-completion of previously defined rewrite theorems \end{enumerate} \\
  $A5_{1}$ & Flip Next and Previous in the GUI. \\
  $A5_{2}$ & Some sort of search (``I want to use this'') would be handy.  The coloring breaks on exceptions. \\
  \bottomrule
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\linewidth}{@{}cX@{}}
  \toprule
  Participant & \multicolumn{1}{c}{
    \textbf{Do you have suggestions on how to improve the tool you used today?}
  } \\ \midrule
  $B1_{1}$ & \begin{enumerate} \item Highlight the border of the sub-window (code/proof) that has keyboard focus, \item When deep in a proof tree, I kept forgetting what induction hypothesis I had accumulated so far (and I think I didn't always see them in the current goal).  It would be useful to somehow get reminded of what invariants/induction hypothesis I had accumulated. \end{enumerate} \\
  $B1_{2}$ & A first time user might find it difficult to switch between cases using ``['' and ``]''.  Some syntax in languages were not straightforward, for instance \safecoqinline{fold}.  Syntax of \safecoqinline{map} functions were clear. \\
  $B2_{1}$ & Maybe look ahead and see if some paths don't lead to solutions. \\
  $B2_{2}$ & \emph{No answer provided.} \\
  $B3_{1}$ & \emph{No answer provided.} \\
  $B3_{2}$ & I guess it's definitely helpful if the tool can automatically probing some paths without clicking. \\
  $B4_{1}$ & \begin{enumerate} \item Trivialize options that lead to the target in one to two steps. \item On the fly explanation of what the operators do. \end{enumerate} \\
  $B4_{2}$ & It crashes when you hit the left button three or four times quickly. \\
  $B5_{1}$ & There was that one bug that we ran into a few times: going back causing the editor to crash, that made us lose progress a few times.  \begin{enumerate} \item An auto-save feature would be appreciated as a guard against this (could use e.g. Local Storage API), \item A way to ``bookmark'' and jump back to points in the tree would be appreciated, perhaps also some highlights of previously explored paths? \end{enumerate} \\
  $B5_{2}$ & A minor one: \safecoqinline{intros.} should be option one (instead of \safecoqinline{intro x.}) since it always seems like the right start. \\
  \bottomrule
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\linewidth}{@{}cX@{}}
  \toprule
  Participant & \multicolumn{1}{c}{
    \textbf{Explain in your own word what the \safecoqinline{each} tactic does.}
  } \\ \midrule
  $A1_{1}$ & Splits up an \safecoqinline{AND} so each side can be proven separately. \\
  $A1_{2}$ & Split/divides a proof of an \safecoqinline{AND} expression into two different proof exercises. \\
  $A2_{1}$ & Used to prove both paths of a theorem (conjunction) with two parts. \\
  $A2_{2}$ & Splits a logical \safecoqinline{and} into subgoals for each expression. \\
  $A3_{1}$ & Follow both branches of an \safecoqinline{AND}, since both must be proven. \\
  $A3_{2}$ & Selects the terms from both sides of an \safecoqinline{AND}. \\
  $A4_{1}$ & Enumerates all cases in a conjunction. \\
  $A4_{2}$ & Divides the \safecoqinline{AND} predicate into two sub-problems so we can prove each separately. \\
  $A5_{1}$ & Splits an \safecoqinline{and} into each side so they can be proved separately. \\
  $A5_{2}$ & Split conjunction. \\
  \bottomrule
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\linewidth}{@{}cX@{}}
  \toprule
  Participant & \multicolumn{1}{c}{
    \textbf{Explain in your own word what the \safecoqinline{each} tactic does.}
  } \\ \midrule
  $B1_{1}$ & For a goal \safecoqinline{A /\ B} introduces 2 subgoals \safecoqinline{A} and \safecoqinline{B}. \\
  $B1_{2}$ & Prove each child tree is correct. \\
  $B2_{1}$ & Applies some function to all elements in a set. \\
  $B2_{2}$ & Prove all sub-trees. \\
  $B3_{1}$ & Every element in a collection. \\
  $B3_{2}$ & Try to prove each case. \\
  $B4_{1}$ & Apply action to all elements of a collection. \\
  $B4_{2}$ & ? \\
  $B5_{1}$ & When you have \safecoqinline{A /\ B}, you need to prove both \safecoqinline{A} and \safecoqinline{B}, so split, doing \safecoqinline{A} and then \safecoqinline{B}. \\
  $B5_{2}$ & Splits an \safecoqinline{A /\ B} goal into separate \safecoqinline{A} and \safecoqinline{B} goals. \\
  \bottomrule
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\linewidth}{@{}cX@{}}
  \toprule
  Participant & \multicolumn{1}{c}{
    \textbf{Explain in your own word what the \safecoqinline{intro} tactic does.}
  } \\ \midrule
  $A1_{1}$ & Fixes some \safecoqinline{forall} value. \\
  $A1_{2}$ & Introduces the different variables in the expression. \\
  $A2_{1}$ & Instantiates the \safecoqinline{forall} variables. \\
  $A2_{2}$ & Do it first thing? \\
  $A3_{1}$ & Apply a \safecoqinline{foreach}. \\
  $A3_{2}$ & Provides the types for the theorem we are proving. \\
  $A4_{1}$ & Instantiates a placeholder variable under a universal quantifier. \\
  $A4_{2}$ & Infers already known information from the setup to give us known or assumed values. \\
  $A5_{1}$ & List names of variables in \safecoqinline{forall} and hypotheses. \\
  $A5_{2}$ & Instantiate \safecoqinline{forall}. \\
  \bottomrule
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\linewidth}{@{}cX@{}}
  \toprule
  Participant & \multicolumn{1}{c}{
    \textbf{Explain in your own word what the \safecoqinline{intro} tactic does.}
  } \\ \midrule
  $B1_{1}$ & Given a \safecoqinline{forall x, p(x)} goal, make up a new variable name \safecoqinline{x} and introduce it and make \safecoqinline{p(x)} (with that specific \safecoqinline{x}) the current sub-goal. \\
  $B1_{2}$ & Introduce (or define) the variables used in proof. \\
  $B2_{1}$ & Introduces all the components of your proof in order to use them. \\
  $B2_{2}$ & Introduce quantified variables (i.e. give them a name). \\
  $B3_{1}$ & Extend the original theorem to an easy-to-understand format. \\
  $B3_{2}$ & Give a start point. \\
  $B4_{1}$ & Add facts to your assumptions. \\
  $B4_{2}$ & ? \\
  $B5_{1}$ & Take the names from the \safecoqinline{forall} and put them in the usable rule environment.  It was sort of unclear to me why we needed to do this explicitly every time. \\
  $B5_{2}$ & Equivalent of the mathematician's ``fix'', gets rid of \safecoqinline{forall}. \\
  \bottomrule
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\linewidth}{@{}cX@{}}
  \toprule
  Participant & \multicolumn{1}{c}{
    \textbf{Explain in your own word what the \safecoqinline{induction} tactic does.}
  } \\ \midrule
  $A1_{1}$ & Allows case analysis over inductive types. \\
  $A1_{2}$ & Applies induction the variable mentioned as parameter and breaks the proof into base case and general case. \\
  $A2_{1}$ & To use induction on a given variable.  Proof by cases analysis. \\
  $A2_{2}$ & Perform induction with two steps/goals: base case + inductive case. \\
  $A3_{1}$ & Break a step into its base case(s) and recursive case(s). \\
  $A3_{2}$ & Performs induction on an element. \\
  $A4_{1}$ & Breaks a logical statement universally quantifying over a variable \safecoqinline{x}, into cases based on \safecoqinline{match}. \\
  $A4_{2}$ & Performs mathematical induction.  Divides into base case, induction case.  Assumes hypothesis. \\
  $A5_{1}$ & Breaks a list into the base case and induction step. \\
  $A5_{2}$ & Induct over recursive variable. \\
  \bottomrule
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\linewidth}{@{}cX@{}}
  \toprule
  Participant & \multicolumn{1}{c}{
    \textbf{Explain in your own word what the \safecoqinline{induction} tactic does.}
  } \\ \midrule
  $B1_{1}$ & If \safecoqinline{x} is of a given type (like ML algebraic types), do a case analysis for each of the constructors of the type.  If one of them is recursive, introduce a hypothesis for its sub-part, and use it to prove the statement for the larger goal. \\
  $B1_{2}$ & Split into two branches: base case and induction case.  Introduce a hypothesis argument called \safecoqinline{IH} which can be invoked later in the proof. \\
  $B2_{1}$ & Proves that some function works for arbitrary element. \\
  $B2_{2}$ & Start an inductive proof (base case + step). \\
  $B3_{1}$ & \begin{enumerate} \item Base case, \item Induction... \end{enumerate} \\
  $B3_{2}$ & It's just ``induction'' we do... counting base case, inductive hypothesis, inductive steps. \\
  $B4_{1}$ & Do structural induction of a... \\
  $B4_{2}$ & Proof by induction. \\
  $B5_{1}$ & Case analysis: break e.g. a list into \safecoqinline{nil} and \safecoqinline{cons}, and branch along each path with an additional inductive hypothesis, proving each path (one for each possible value/case) proves the overall theorem. \\
  $B5_{2}$ & Splits a goal involving a recursively-defined data type into a base case and an inductive step goal (in the latter, you get the inductive hypothesis in the environment). \\
  \bottomrule
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\linewidth}{@{}cX@{}}
  \toprule
  Participant & \multicolumn{1}{c}{
    \textbf{Explain in your own word what the \safecoqinline{reflexivity} tactic does.}
  } \\ \midrule
  $A1_{1}$ & Used when x = x. \\
  $A1_{2}$ & Comparing an expression with itself is true. \\
  $A2_{1}$ & Used to prove equality when both sides of the equality is the same (or very similar after simplifying). \\
  $A2_{2}$ & Attempt to reconcile an equality. \\
  $A3_{1}$ & When you have \safecoqinline{x = x}, call that step finished and move on to the next. \\
  $A3_{2}$ & Simplifies like expressions on both sides of the equality. \\
  $A4_{1}$ & Uses the tautological identity to prove trivial equalities.  Also does \safecoqinline{simpl}. \\
  $A4_{2}$ & \safecoqinline{A == A}. \\
  $A5_{1}$ & Simplifies and accepts if both sides are the same. \\
  $A5_{2}$ & Apply functions, find structural equality. \\
  \bottomrule
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\linewidth}{@{}cX@{}}
  \toprule
  Participant & \multicolumn{1}{c}{
    \textbf{Explain in your own word what the \safecoqinline{reflexivity} tactic does.}
  } \\ \midrule
  $B1_{1}$ & \safecoqinline{x = x} is trivially true. \\
  $B1_{2}$ & \safecoqinline{a = a}.  Also simplifies based on definition of types. \\
  $B2_{1}$ & Two things are equivalent. \\
  $B2_{2}$ & Check if two things are equal. \\
  $B3_{1}$ & \safecoqinline{x = x}. \\
  $B3_{2}$ & Trivial equivalence. \\
  $B4_{1}$ & Use the reflexive property (along with some simplification). \\
  $B4_{2}$ & Checks if two things are the same. \\
  $B5_{1}$ & Prove \safecoqinline{a = a} for some \safecoqinline{a}. \\
  $B5_{2}$ & Proves \safecoqinline{x = x} (also performs simple simplifications). \\
  \bottomrule
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\linewidth}{@{}cX@{}}
  \toprule
  Participant & \multicolumn{1}{c}{
    \textbf{Explain in your own word what the \safecoqinline{rewrite} tactic does.}
  } \\ \midrule
  $A1_{1}$ & Used to pull in some fact proven earlier. \\
  $A1_{2}$ & Uses the rule provided to find a component in LHS/RHS (depending on arrow) and modify it (as per the rule). \\
  $A2_{1}$ & Uses a rule to rewrite a part of the proof. \\
  $A2_{2}$ & Pattern-match and replace. \\
  $A3_{1}$ & Rewrite the current step with a specified function. \\
  $A3_{2}$ & Applies an equality to your current goal or sub-goal. \\
  $A4_{1}$ & Pattern-match part of an expression using a (inductive) hypothesis in scope. \\
  $A4_{2}$ & Substitution. \\
  $A5_{1}$ & Replaces one side of an expression with the other. \\
  $A5_{2}$ & Replace equal terms. \\
  \bottomrule
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\linewidth}{@{}cX@{}}
  \toprule
  Participant & \multicolumn{1}{c}{
    \textbf{Explain in your own word what the \safecoqinline{rewrite} tactic does.}
  } \\ \midrule
  $B1_{1}$ & Use a previous lemma/induction hypothesis to transform some terms. \\
  $B1_{2}$ & Replace parts of LHS, RHS, using the theorems proved earlier. \\
  $B2_{1}$ & Use previous lemma or theorems to modify the construct. \\
  $B2_{2}$ & Use previously proven things to rewrite the expression. \\
  $B3_{1}$ & Rewrite some formulas to ones that are closer to the proof's target.  Better to utilize the existing hypothesis. \\
  $B3_{2}$ & Transformation. \\
  $B4_{1}$ & Use some rewrite property applied to parts of your expressions. \\
  $B4_{2}$ & Replaces a pattern in the text. \\
  $B5_{1}$ & Use a theorem/inductive hypothesis/other rewrite rule to transform part of the current node and continue with the proof. \\
  $B5_{2}$ & ``Substitution'' or ``plugging int''. \\
  \bottomrule
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\linewidth}{@{}cX@{}}
  \toprule
  Participant & \multicolumn{1}{c}{
    \textbf{Explain in your own word what the \safecoqinline{goright} tactic does.}
  } \\ \midrule
  $A1_{1}$ & Tells proof assistant I'm about to prove the right-hand side of an \safecoqinline{OR}. \\
  $A1_{2}$ & Choose the right-side expression in a combination of Boolean expressions. \\
  $A2_{1}$ & To prove the right part of an \safecoqinline{OR} expression. \\
  $A2_{2}$ & Take a goal with a logical \safecoqinline{or} and solve only the right sub-expression. \\
  $A3_{1}$ & Follow the right branch of an \safecoqinline{OR}, ignoring the left. \\
  $A3_{2}$ & Selects the right side of a logical comparison. \\
  $A4_{1}$ & Try to prove the second clause in a disjunction. \\
  $A4_{2}$ & Discard left side of the \safecoqinline{or} predicate. \\
  $A5_{1}$ & Selects the right-hand side of an \safecoqinline{or} gate to try to prove. \\
  $A5_{2}$ & Follow right arm of disjunction. \\
  \bottomrule
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\linewidth}{@{}cX@{}}
  \toprule
  Participant & \multicolumn{1}{c}{
    \textbf{Explain in your own word what the \safecoqinline{goright} tactic does.}
  } \\ \midrule
  $B1_{1}$ & Given a goal \safecoqinline{A \/ B} try to prove \safecoqinline{B}. \\
  $B1_{2}$ & While proving \safecoqinline{\/}, choose the right clause to prove. \\
  $B2_{1}$ & Choose the right hand goal of an \safecoqinline{OR} construct to continue a proof. \\
  $B2_{2}$ & Prove the right side of the \safecoqinline{\/} expression. \\
  $B3_{1}$ & Prove the right side. \\
  $B3_{2}$ & For \safecoqinline{A \/ B} or \safecoqinline{A /\ B}, try to prove the right proposition. \\
  $B4_{1}$ & Prove the right part of a disjunction. \\
  $B4_{2}$ & Visits the right-hand side of an \safecoqinline{OR} statement. \\
  $B5_{1}$ & When you have \safecoqinline{A \/ B}, you need to prove \safecoqinline{A} or \safecoqinline{B}, here, we choose to prove \safecoqinline{B} to prove the overall statement. \\
  $B5_{2}$ & Replaces \safecoqinline{A \/ B} goal with \safecoqinline{B}. \\
  \bottomrule
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\textwidth}{ | c || *{6}{Y|} }
  \hline
  Participant & \multicolumn{5}{c|}{
    \textbf{I found the tool easy to understand.}
  } \\ \hline
  & \makecell{Strongly\\disagree} & Disagree & Neutral & Agree & \makecell{Strongly\\agree} \\ \hline
  $A1_{1}$ &   &   &   &   &\OK\\ \hline
  $A1_{2}$ &   &   &   &\OK&   \\ \hline
  $A2_{1}$ &   &   &   &\OK&   \\ \hline
  $A2_{2}$ &   &   &\OK&   &   \\ \hline
  $A3_{1}$ &   &   &   &\OK&   \\ \hline
  $A3_{2}$ &   &   &   &   &\OK\\ \hline
  $A4_{1}$ &   &   &   &   &\OK\\ \hline
  $A4_{2}$ &   &   &\OK&   &   \\ \hline
  $A5_{1}$ &   &   &   &   &\OK\\ \hline
  $A5_{2}$ &   &   &   &   &\OK\\ \hline \hline
  $B1_{1}$ &   &   &   &   &\OK\\ \hline
  $B1_{2}$ &   &   &   &\OK&   \\ \hline
  $B2_{1}$ &   &   &   &   &\OK\\ \hline
  $B2_{2}$ &   &   &   &\OK&   \\ \hline
  $B3_{1}$ &   &   &\OK&   &   \\ \hline
  $B3_{2}$ &   &   &   &   &\OK\\ \hline
  $B4_{1}$ &   &   &   &   &\OK\\ \hline
  $B4_{2}$ &   &\OK&   &   &   \\ \hline
  $B5_{1}$ &   &   &   &\OK&   \\ \hline
  $B5_{2}$ &   &   &   &   &\OK\\ \hline
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\textwidth}{ | c || *{6}{Y|} }
  \hline
  Participant & \multicolumn{5}{c|}{
    \textbf{ I found the session educational. }
  } \\ \hline
  & \makecell{Strongly\\disagree} & Disagree & Neutral & Agree & \makecell{Strongly\\agree} \\ \hline
  $A1_{1}$ &   &   &   &   &\OK\\ \hline
  $A1_{2}$ &   &   &   &   &\OK\\ \hline
  $A2_{1}$ &   &   &   &   &\OK\\ \hline
  $A2_{2}$ &   &   &   &   &\OK\\ \hline
  $A3_{1}$ &   &   &   &   &\OK\\ \hline
  $A3_{2}$ &   &   &\OK&   &   \\ \hline
  $A4_{1}$ &   &   &   &\OK&   \\ \hline
  $A4_{2}$ &   &   &   &\OK&   \\ \hline
  $A5_{1}$ &   &   &   &   &\OK\\ \hline
  $A5_{2}$ &   &   &   &   &\OK\\ \hline \hline
  $B1_{1}$ &   &   &   &   &\OK\\ \hline
  $B1_{2}$ &   &   &   &\OK&   \\ \hline
  $B2_{1}$ &   &   &   &   &\OK\\ \hline
  $B2_{2}$ &   &   &   &   &\OK\\ \hline
  $B3_{1}$ &   &   &   &   &\OK\\ \hline
  $B3_{2}$ &   &   &\OK&   &   \\ \hline
  $B4_{1}$ &   &   &   &   &\OK\\ \hline
  $B4_{2}$ &   &\OK&   &   &   \\ \hline
  $B5_{1}$ &   &   &   &   &\OK\\ \hline
  $B5_{2}$ &   &   &   &\OK&   \\ \hline
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\textwidth}{ | c || *{6}{Y|} }
  \hline
  Participant & \multicolumn{5}{c|}{
    \textbf{ I found the session fun. }
  } \\ \hline
  & \makecell{Strongly\\disagree} & Disagree & Neutral & Agree & \makecell{Strongly\\agree} \\ \hline
  $A1_{1}$ &   &   &   &\OK&   \\ \hline
  $A1_{2}$ &   &   &   &\OK&   \\ \hline
  $A2_{1}$ &   &   &   &   &\OK\\ \hline
  $A2_{2}$ &   &   &\OK&   &   \\ \hline
  $A3_{1}$ &   &   &   &\OK&   \\ \hline
  $A3_{2}$ &   &   &   &\OK&   \\ \hline
  $A4_{1}$ &   &   &   &\OK&   \\ \hline
  $A4_{2}$ &   &   &   &\OK&   \\ \hline
  $A5_{1}$ &   &   &   &   &\OK\\ \hline
  $A5_{2}$ &   &   &   &\OK&   \\ \hline \hline
  $B1_{1}$ &   &   &   &   &\OK\\ \hline
  $B1_{2}$ &   &   &   &   &\OK\\ \hline
  $B2_{1}$ &   &   &   &   &\OK\\ \hline
  $B2_{2}$ &   &   &   &\OK&   \\ \hline
  $B3_{1}$ &   &   &   &   &\OK\\ \hline
  $B3_{2}$ &   &   &   &\OK&   \\ \hline
  $B4_{1}$ &   &   &   &   &\OK\\ \hline
  $B4_{2}$ &\OK&   &   &   &   \\ \hline
  $B5_{1}$ &   &   &   &\OK&   \\ \hline
  $B5_{2}$ &   &   &   &\OK&   \\ \hline
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\textwidth}{ | c || *{6}{Y|} }
  \hline
  Participant & \multicolumn{5}{c|}{
    \textbf{ I would like to continue using this tool. }
  } \\ \hline
  & \makecell{Strongly\\disagree} & Disagree & Neutral & Agree & \makecell{Strongly\\agree} \\ \hline
  $A1_{1}$ &   &\OK&   &   &   \\ \hline
  $A1_{2}$ &   &   &\OK&   &   \\ \hline
  $A2_{1}$ &   &   &   &\OK&   \\ \hline
  $A2_{2}$ &\OK&   &   &   &   \\ \hline
  $A3_{1}$ &   &\OK&   &   &   \\ \hline
  $A3_{2}$ &   &   &   &\OK&   \\ \hline
  $A4_{1}$ &   &   &   &\OK&   \\ \hline
  $A4_{2}$ &   &   &   &\OK&   \\ \hline
  $A5_{1}$ &   &   &   &   &\OK\\ \hline
  $A5_{2}$ &   &   &   &\OK&   \\ \hline \hline
  $B1_{1}$ &   &   &   &   &\OK\\ \hline
  $B1_{2}$ &   &   &   &   &\OK\\ \hline
  $B2_{1}$ &   &   &   &\OK&   \\ \hline
  $B2_{2}$ &   &   &\OK&   &   \\ \hline
  $B3_{1}$ &   &   &\OK&   &   \\ \hline
  $B3_{2}$ &   &   &\OK&   &   \\ \hline
  $B4_{1}$ &   &   &   &   &\OK\\ \hline
  $B4_{2}$ &   &   &\OK&   &   \\ \hline
  $B5_{1}$ &   &   &   &\OK&   \\ \hline
  $B5_{2}$ &   &   &   &   &\OK\\ \hline
\end{tabularx}{\parfillskip=0pt\par}

\clearpage

\noindent
\begin{tabularx}{\textwidth}{ | c || *{6}{Y|} }
  \hline
  Participant & \multicolumn{5}{c}{
    \textbf{ I would recommend this session to a friend. }
  } \\ \hline
  & \makecell{Strongly\\disagree} & Disagree & Neutral & Agree & \makecell{Strongly\\agree} \\ \hline
  $A1_{1}$ &   &   &   &   &\OK\\ \hline
  $A1_{2}$ &   &   &   &\OK&   \\ \hline
  $A2_{1}$ &   &   &   &   &\OK\\ \hline
  $A2_{2}$ &   &   &   &\OK&   \\ \hline
  $A3_{1}$ &   &   &   &\OK&   \\ \hline
  $A3_{2}$ &   &   &   &\OK&   \\ \hline
  $A4_{1}$ &   &   &   &\OK&   \\ \hline
  $A4_{2}$ &   &   &   &\OK&   \\ \hline
  $A5_{1}$ &   &   &   &   &\OK\\ \hline
  $A5_{2}$ &   &   &   &\OK&   \\ \hline \hline
  $B1_{1}$ &   &   &   &\OK&   \\ \hline
  $B1_{2}$ &   &   &   &\OK&   \\ \hline
  $B2_{1}$ &   &   &   &   &\OK\\ \hline
  $B2_{2}$ &   &   &   &\OK&   \\ \hline
  $B3_{1}$ &   &   &   &\OK&   \\ \hline
  $B3_{2}$ &   &   &   &\OK&   \\ \hline
  $B4_{1}$ &   &   &   &   &\OK\\ \hline
  $B4_{2}$ &\OK&   &   &   &   \\ \hline
  $B5_{1}$ &   &   &   &\OK&   \\ \hline
  $B5_{2}$ &   &   &   &   &\OK\\ \hline
\end{tabularx}{\parfillskip=0pt\par}
