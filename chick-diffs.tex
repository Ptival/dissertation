\section{Describing program modifications with diffs}\label{chick-diffs}

We define a family of data types that allows us to describe changes made to
programs from the language presented in Section~\ref{chick-syntax-programs}.  We
will refer to these descriptions of changes as \textit{diffs}.  We will usually
denote a \textit{diff type} $\delta_{\tau}$ if it corresponds to values of the
diffed type $\tau$.  Informally, one can think of the type $\delta_{\tau}$ as a
descriptor for how some value $v_{1}$ of type $\tau$ can be transformed into
another value $v_{2}$.

It is important to clarify how we intend to use those diff types.  We will want
to describe changes made to the data types in the abstract syntax tree of the
user's program.  An example will help us avoid some misconception: consider the
user program and its modification in Figure~\ref{bool-modification}.  While,
from the program point of view, a value of type \coqinline{bool} was modified
from the value \coqinline{True} to the value \coqinline{False}, we will
\emph{not} use the type $\delta_{\coqinline{bool}}$ to describe this change!
From the point of view of the abstract syntax tree, a value of type
\coqinline{term} has changed from the original value \coqinline{Var "True"} to
the value \coqinline{Var "False"}, which we will capture using the diff type
$\delta_{\coqinline{term}}$.

To be precise, we will have to describe how a \coqinline{Definition} has
changed, and describe how its name has remained \coqinline{a}, its type has
remained \coqinline{bool}, but its definition has changed.  This will be
described as a value of type $\delta_{\coqinline{vernac}}$, containing a diff
for each of those three components that may change, including the one of diff
type $\delta_{\coqinline{term}}$.

\begin{figure*}[!htp]

  \noindent%
  \begin{minipage}[t]{0.50\textwidth}
    \begin{minted}[linenos=false]{coq}
Inductive bool : Set :=
| True  : bool
| False : bool.

Definition a : bool := True.
\end{minted}
\end{minipage}%
\begin{minipage}[t]{0.50\textwidth}
  \begin{minted}[escapeinside=@@,linenos=false]{coq}
Inductive bool : Set :=
| True  : bool
| False : bool.

Definition a : bool := @\modified{False}@.
\end{minted}
\end{minipage}

\caption{A simple program and its modification}

\label{bool-modification}

\end{figure*}

When the user makes a change to their program, we will attempt to guess the
structure of their changes, as a value of one of the program diff type
$\delta_{\coqinline{program}}$.  To illustrate the kind of changes we are
interested in describing, let us look back at our motivating example in
Figure~\ref{listtovec}, where we can observe the following partial attempts at
refactoring:

\begin{enumerate}

\item they renamed \coqinline{list} into \coqinline{vec},

\item added an index of type \coqinline{nat},

\item renamed constructor \coqinline{nil} into \coqinline{vnil},

\item instantiated the index for the first constructor with \coqinline{O},

\item renamed constructor \coqinline{cons} into \coqinline{vcons},

\item added a parameter \coqinline{n} of type \coqinline{nat} to the second
  constructor,

\item updated the recursive occurrence's name,

\item updated the recursive occurrence's index,

\item and instantiated the index for the second constructor with \coqinline{(S n)}.

\end{enumerate}

Intuitively, we want to capture changes like insertion, modifications,
deletions, and permutations, at all syntactic levels of the meta-language
(within terms, within inductive declarations).  We will use the same
descriptions to capture user-provided and repair-generated modifications.

Every diff type is accompanied by a patching function, which, given an element
of the diffed type and an element of the diff type produces, when successful, a
patched element.  This operation is partial for many diff types, because they
often capture modifications that only make sense for certain constructors of the
diffed type: for instance, a diff that says the head of a list has been modified
does not apply to the empty list.  We will overload the notation
$\MathPatches{x}{\delta_x}{x'}$ to indicate that $x'$ is the (optional) value
obtained when (successfully) patching $x$ according to the diff $\delta_x$,
using the relevant patching function for that diff type.  In all of our
notations, we use a black frame and a teal highlight to indicate that a value is
an output.

\subsection{Atomic diff}

There are many data types for which we will only capture changes at an atomic
granularity: either the value is the same in the new program, or it has been
replaced with a different, unrelated value.  For instance, a binder can either
have the same name, or have been renamed.  Similarly, the only possible change
to the recursive flag of a definition is to be atomically changed to a different
value.  The parameterized $\delta_{atomic}$ diff type captures such cases for a
given type $\tau$:

\begin{grammar}
<$\delta_{atomic}\ \tau$> ::= \ %trick LaTeX
\alt $\MathSame$                        \hfill (unchanged)
\alt $\MathReplace{\langle\tau\rangle}$ \hfill (replaced)
\end{grammar}
%
with the following semantics:

\begin{mathpar}
  {
    \inferrule*
    [right=Identity]
    {  }
    {\MathPatches{x}{\MathSame}{x}}
  }

  {
    \inferrule*
    [right=Replace]
    {  }
    {\MathPatches{x}{\MathReplace{y}}{y}}
  }

\end{mathpar}

\paragraph{Note} We sometimes indicate

\subsection{List diff}~\label{list-diff}

For lists, we provide a rich selection of diff operations.  The aim is not to
have a canonical representation, but rather to capture closely the intent of
the user modifications:

\begin{grammar}
<$\delta_{\text{list}} \ \tau \ \delta_{\tau}$> ::= \ %trick LaTeX
\alt \synt{$\delta_{\text{atomic}}\ \tau$} \hfill (atomic modification of the whole list)
\alt \begin{tabular}{p{0.7cm} >{\centering}p{0.7cm} l}$\langle\tau\rangle$
       & $\MathIns{}{}$
       & \synt{$\delta_{list}\ \tau\ \delta_{\tau}$} \\\end{tabular} \hfill
     (insert a head)
\alt \begin{tabular}{p{0.7cm} >{\centering}p{0.7cm} l}$\langle\delta_\tau\rangle$
       & $\MathMod{}{}$
       & \synt{$\delta_{list}\ \tau\ \delta_{\tau}$} \\\end{tabular}
     \hfill (modify and keep the head)
%\alt \begin{tabular}{p{0.3cm} >{\centering}p{0.6cm} l}\quad & $\MathKeep{}$
%       & \synt{$\delta_{list}\ \tau\ \delta_{\tau}$} \\\end{tabular}
%     \hfill (keep the head)
\alt \begin{tabular}{p{0.7cm} >{\centering}p{0.7cm} l}\quad
       & $\MathDrop{}$
       & \synt{$\delta_{list}\ \tau\ \delta_{\tau}$} \\\end{tabular}
     \hfill (drop the head)
\alt \begin{tabular}{p{0.7cm} >{\centering}p{0.7cm} l}\quad
       & $\MathPermute{p}{}$
       & \synt{$\delta_{\text{list}}\ \tau\ \delta_{\tau}$} \\\end{tabular}
     \hfill (permute according to a permutation $p$)
\end{grammar}
%
with the following semantics:

\begin{mathpar}
  {
    \inferrule*
    [right=Insert]
    {\MathPatches{l}{\delta_{l}}{l'}}
    {\MathPatches{l}{\MathIns{h}{\delta_{l}}}{(h :: l')}}
  }

  {
    \inferrule*
    [right=Modify]
    {\MathPatches{h}{\delta_{h}}{h'} \quad \MathPatches{t}{\delta_{t}}{t'}}
    {\MathPatches{(h :: t)}{\MathMod{\delta_{h}}{\delta_{t}}}{(h' :: t')}}
  }
\\
  % {
  %   \inferrule*
  %   [right=Keep]
  %   {\MathPatches{t}{\delta_{t}}{t'}}
  %   {\MathPatches{(h :: t)}{\MathKeep{\delta_{t}}}{(h :: t')}}
  % }
  {
    \inferrule*
    [right=Drop]
    {\MathPatches{t}{\delta_{t}}{t'}}
    {\MathPatches{(h :: t)}{\MathDrop{\delta_{t}}}{t'}}
  }

  {
    \inferrule*
    [right=Permute]
    {\MathPatches{(h_{p(1)} \Cons \ldots \Cons h_{p(|p|)} \Cons t)}{\delta}{l}}
    {\MathPatches{(h_1 \Cons \ldots \Cons h_{|p|} \Cons t)}{\MathPermute{p}{\delta}}{l}}
  }

\end{mathpar}

Note that we defined the semantics of $\MathModPiOp$ so that it both modifies
and keeps the head: the recursive occurrence in rule~\rulename{Modify},
$\delta_t$, therefore applies to the tail $t$ and not the whole list after the
head has been repaired.  On the other hand, the recursive occurrence in
rule~\rulename{Permute}, $\delta$, targets the entire list after the permutation
is performed, not solely the tail: this is necessary because we will want to
perform modifications of elements after having shuffled them around.

\subsection{Term diff}\label{chick-diffs-term-diff}

The diffs for terms include atomic changes, as well as insertion, modification,
deletion, and permutation of most constructors.  We illustrate a couple of
these:

\begin{grammar}
<$\delta_{term}$> ::= \ %trick LaTeX
\alt \synt{$\delta_{atomic}\ t$} \hfill (atomic modification)
\alt \synt{$\delta_{term}$} $\oIns{ \$ }$ \synt{$\delta_{term}$} \hfill
(insert application)
\alt $\oIns{\lambda}$ \synt{v}, \synt{$\delta_{term}$} \hfill (insert value
abstraction)
\alt $\oIns{\Pi}$ (\synt{v} : \synt{$\delta_{term}$}),
\synt{$\delta_{term}$} \hfill (insert type abstraction)
\alt ... \hfill (other insertions)
\alt ... \hfill (removals/modifications/permutations)
\end{grammar}

\noindent Note that we use an infix dollar sign ($\$$) as a symbol for function
application in our diffs, even though we use an infix space for function
application in our terms, which is not ideal but should prevent confusion.  For
our purpose, we biased the diffs on binary operations in the least surprising
way: deleting a function application keeps its left child, i.e. removes the
function call and keeps the function (see rule~\rulename{\RmApp}), while
deleting a \coqinline{Pi} keeps its right child, i.e. removes the value being
quantified but keeps the return type (see rule~\rulename{\RmPi}).  For
insertion, we allow maximal flexibility by passing the entire old term to all
recursive occurrences: for instance, the diff
$(\MathInsApp{\MathSame}{\MathSame})$ turns any term $t$ into the
self-application $(t\ t)$ (see rule~\rulename{\InsApp}).  However, it is often
the case that only one recursive occurrence will use the original term, while
the other ones will replace it: for instance, the diff
$(\MathInsApp{\MathSame}{\MathReplace{x}})$ turns any term $t$ into the
application $(t\ x)$.

\begin{mathpar}
  {
    \inferrule*
    [right=\RmApp]
    {\MathPatches{f}{\delta}{f'}}
    {\MathPatches{f\ x}{\MathDropApp{\delta}}{f'}}
  }

  {
    \inferrule*
    [right=\RmPi]
    {\MathPatches{\tau_{2}}{\delta}{\tau_{2}'}}
    {\MathPatches{\MathPi{\tau_{1}}{x}{\tau_{2}}}{\MathDropPi{\delta}}{\tau_{2}'}}
  }

\\

  {
    \inferrule*
    [right=\InsApp]
    {\MathPatches{t}{\delta_1}{t_1} \quad \MathPatches{t}{\delta_2}{t_2}}
    {\MathPatches{t}{\MathInsApp{\delta_1}{\delta_2}}{t_1\ t_2}}
  }

\end{mathpar}

\subsection{Other diff types}

We also need diffs for many other internal data types.  Diff types for tuples
are derived from diff types of their constituents in a straightforward way.
Inductive data type definitions, as well as constructor definitions, behave
essentially like a tuple of all their arguments, so their diff type is derived
accordingly.

\subsection{Example of a program diff}

With all of this machinery, we can define the original diff for our running
example (again, referring to the changes seen on Figure~\ref{listtovec}) as
shown in Figure~\ref{diff-list-vec}.  Because the diffs for the constructors
take a lot of space, they are abbreviated as $\delta \coqinline{nil}$ and
$\delta \coqinline{cons}$, and shown separately in
Figures~\ref{diff-list-vec-nil} for \coqinline{nil} and~\ref{diff-list-vec-cons}
for \coqinline{cons}.

\begin{figure*}[!htp]

  \noindent%
  \begin{minipage}[t]{0.50\textwidth}
    \begin{minted}[fontsize=\footnotesize,linenos=false]{coq}
Inductive nat : Set :=
| O : nat
| S : ∀ (n : nat), nat.

Inductive list (A : Type)
: Type := ...

(* rest of program *)
    \end{minted}
  \end{minipage}%
  \begin{minipage}[t]{0.50\textwidth}
    \begin{minted}[fontsize=\footnotesize,escapeinside=@@,linenos=false]{coq}
Inductive nat : Set :=
| O : nat
| S : ∀ (n : nat), nat.

Inductive @\modified{vec}@ (A : Type)
: @\modified{nat →}@ Type := ...

(* identical rest of program *)
    \end{minted}
  \end{minipage}

  \vspace{2em}%

  \begin{align*}
&\MathSame{}_{\InductiveText} \MathMod{}{} && \text{do not modify inductive \coqinline{nat}}\\
& \delta_{\InductiveText} ( && \text{modify \coqinline{list} into \coqinline{vec}} \\
& \qquad \MathReplace{\coqinline{vec}}, && \text{modify the name} \\
& \qquad \MathSame{}_{\text{list}},       && \text{keep the parameter} \\
& \qquad \MathIns{\coqinline{nat}}{\MathSame{}_{\text{list}}}, && \text{add the \coqinline{nat} index} \\
& \qquad \MathSame{}_{\text{universe}}, && \text{keep the universe} \\
& \qquad \MathMod{\delta\coqinline{nil}}{\MathMod{\delta\coqinline{cons}}{\MathSame{}_{\text{list}}}}
  && \text{modify the constructors (elided)} \\
& ) \MathMod{}{} && \\
& \MathSame{}_{\text{list}} && \text{do not modify the rest of the program}
  \end{align*}

  \caption{Diff for our running example (constructors elided)}
  \label{diff-list-vec}

\end{figure*}

While the inductive diff should be somewhat straightforward, readers might be
surprised by $\delta\coqinline{nil}$ in Figure~\ref{diff-list-vec-nil} not
mentioning the renaming of \coqinline{list} (on the left) into \coqinline{vec}
on the right.  While this renaming appears syntactically in the concrete syntax,
it is only a surface-level syntactic requirement that constructors repeat the
type they inhabit.  In practice, the abstract syntax tree only contains the list
of indices, and does not repeat the name of the type or the parameters of the
inductive type.

\begin{figure*}[!htp]

  \noindent%
  \begin{minipage}[t]{0.50\textwidth}
    \begin{minted}[fontsize=\footnotesize,linenos=false]{coq}
...
| nil : list A
  \end{minted}
\end{minipage}%
\begin{minipage}[t]{0.50\textwidth}
  \begin{minted}[fontsize=\footnotesize,escapeinside=@@,linenos=false]{coq}
...
| @\modified{vnil}@ : @\modified{vec}@ A @\modified{O}@
  \end{minted}
\end{minipage}

  \vspace{2em}%

  \begin{align*}
& \delta\coqinline{nil} \coloneqq & && \\
& \qquad \delta_{\ConstructorText} ( && \text{modify the \coqinline{nil} constructor} \\
& \qquad \qquad \MathReplace{\coqinline{vnil}}, && \text{modify constructor name} \\
& \qquad \qquad \MathSame{},                    && \text{no change to parameters} \\
& \qquad \qquad \MathIns{\coqinline{O}}{\MathSame{}}
  && \text{instantiate the \coqinline{nat} index with value \coqinline{O}} \\
& \qquad ) && \\
  \end{align*}

  \caption{Diff for our running example (\coqinline{nil} constructor only)}
  \label{diff-list-vec-nil}

\end{figure*}

One might also find the modification of the parameter in
Figure~\ref{diff-list-vec-cons} hard to read.  The diff
$\MathInsApp{\coqinline{n}}{\MathModApp{\MathReplace{\coqinline{vec}}}{\MathSame{}}}$
might seem inverted, but it only appears so because function application is
left-associative.  Therefore, when comparing \coqinline{list A} with
\coqinline{vec A n}, the outermost application node of the latter does not
correspond to any application node in the former.  The whole original term,
\coqinline{list A}, in fact corresponds to the left-child of the outermost
application node, i.e. \coqinline{vec A}.  Again, the reader might want to refer
to rule~\rulename{\InsApp} from Section~\ref{chick-diffs-term-diff} for the
semantics of $\MathInsApp{}{}$.

\begin{figure*}[!htp]

  \noindent%
  \begin{minipage}[t]{0.50\textwidth}
    \begin{minted}[fontsize=\footnotesize,linenos=false]{coq}
...
| cons : A →
    list A → list A.
  \end{minted}
\end{minipage}%
\begin{minipage}[t]{0.50\textwidth}
  \begin{minted}[fontsize=\footnotesize,escapeinside=@@,linenos=false]{coq}
...
| @\modified{vcons}@ : A → @\modified{∀ (n : nat),}@
    @\modified{vec}@ A @\modified{n}@ → @\modified{vec}@ A @\modified{(S n)}@.
  \end{minted}
\end{minipage}

  \vspace{2em}%

  \begin{align*}
& \delta\coqinline{cons} \coloneqq & && \\
& \qquad \delta_{\ConstructorText} (  & && \text{modify the \coqinline{cons} constructor} \\
& \qquad \qquad \MathReplace{\coqinline{vcons}}, & && \text{modify constructor name} \\
& \qquad \qquad \MathSame{} & \MathMod{}{} && \text{keep the first parameter} \\
& \qquad \qquad ( \coqinline{n} : \coqinline{nat} ) & \MathIns{}{} && \text{insert a second parameter} \\
& \qquad \qquad ( \MathSame{}_{\text{binder}} : \MathInsApp{\coqinline{n}}{\MathModApp{\MathReplace{\coqinline{vec}}}{\MathSame{}}} )
  & \MathMod{}{}
  && \text{modify \coqinline{list A} into \coqinline{vec A O}} \\
& & && \text{while keeping binder anonymous} \\
& \qquad \qquad \MathSame{},                       & && \text{no other parameter} \\
& \qquad \qquad \MathIns{\coqinline{(S n)}}{\MathSame{}} &
  && \text{instantiate the \coqinline{nat} index, no other index} \\
& \qquad ) && \\
  \end{align*}

  \caption{Diff for our running example (\coqinline{cons} constructor only)}
  \label{diff-list-vec-cons}

\end{figure*}

Again, the diff shown in Figure~\ref{diff-list-vec} would be the input to our
repair algorithm, alongside the original program.  The repair algorithm should
propagate changes in such a way as to generate all the other fixes seen in teal
in Figure~\ref{listtovec}.
