\section{Lookup rules}~\label{chick-lookup-rules}

When encountering a variable in a program under repair, we will often need to
answer the question ``What has happened to this variable?''.  In order to do so,
we generalize the usual notion of variable lookup.  In presentations of lambda
calculi where both a global environment and a local context carry typing
information, the usual notion of variable lookup first looks in the local
context (since it carries the ``closest'' enclosing scopes), then, if no binding
is found, looks in the global environment.

We use the following judgments for looking up a variable in the local context
$\Gamma$ (on the left), and in the global environment $E$ (on the
right):~\footnote{While the two judgments share the same syntax, it should
always be clear whether the value to the left of the turnstile is a local
context or a global environment.}

\[
  \turnstile{\Gamma}{ \hasType{ v }{ \out{\tau} } }
  \hspace{1cm}
  \turnstile{E}{ \hasType{ v }{ \out{\tau} } }
\]

The rules for looking up types are straightforward, as shown in
Figures~\ref{lookup-type-dispatch},~\ref{lookup-type-context},
and~\ref{lookup-type-environment}.  In the latter, we handle the complexity of
inductive data type definitions.  For those, a system like \Coq{} will introduce
not only a name for the inductive type being defined, but also one name per
elimination principles it generates, and finally one name per the constructor of
the data type.  This is captured in the lookup rules, where we check those in
order before looking in the rest of the environment.  Unfortunately,
rule~\rulename{\LookupEnv-There} has to be quite bloated, but its premises only
ensure that we look in the rest of the environment only when neither of the
three previous rules hold.

\begin{Rules}{lookup-type-dispatch}{ Lookup rules (local context and global environment) }

\begin{mathpar}
  {
    \inferrule*
    [lab=\LookupCtxt]
    { \turnstile{ \Gamma }{ \hasType{ v }{ \out{\tau} } } }
    { \turnstile{ \context{E}{\ \Gamma} }{ \hasType{ v }{ \out{\tau} } } }
  }

  {
    \inferrule*
    [lab=\LookupEnv]
    {
      \nturnstile{ \Gamma }{ \hasType{ v }{ \out{\tau} } }
      \and
      \turnstile{ E }{ \hasType{ v }{ \out{\tau} } }
    }
    { \turnstile{ \context{E}{\ \Gamma} }{ \hasType{ v }{ \out{\tau} } } }
  }

\end{mathpar}

\end{Rules}

\begin{Rules}{lookup-type-context}{ Lookup rules (local context) }

\begin{mathpar}
  {
    \inferrule*
    [lab=\LookupCtxt-Here]
    {  }
    { \turnstile{ \MathCons{\MathLocalAssum{v}{\tau}}{\Gamma} }{ \hasType{ v }{ \out{\tau} } } }
  }

  {
    \inferrule*
    [lab=\LookupCtxt-There]
    { w \neq v \and \turnstile{ \Gamma }{ \hasType{ v }{ \out{\tau} } } }
    { \turnstile{ \MathCons{\MathLocalAssum{w}{\tau}}{\Gamma} }{ \hasType{ v }{ \out{\tau} } } }
  }

\end{mathpar}

\end{Rules}

\begin{Rules}{lookup-type-environment}{ Lookup rules (global environment) }

\begin{mathpar}

  {
    \inferrule*
    [lab=\LookupEnv-Definition-Here]
    {  }
    { \turnstile{ {\MathCons{\Definition{k}{v}{\tau}{t}}{E}} }{ \hasType{ v }{ \out{\tau} } } }
  }

  {
    \inferrule*
    [lab=\LookupEnv-Definition-There]
    { w \neq v \and \turnstile{ E }{ \hasType{ v }{ \out{\tau} } } }
    { \turnstile{ {\MathCons{\Definition{k}{w}{\tau}{t}}{E}} }{ \hasType{ v }{ \out{\tau} } } }
  }

  {
    \inferrule*
    [lab=\LookupEnv-Inductive-Type-Here]
    {
      I =\Inductive{n}{\overline{p}}{\overline{i}}{u}{\overline{c}}
      \and
      \tau = \op{\text{InductiveType}(} I \op{)}
    }
    { \turnstile{ {\MathCons{I}{E}} }{ \hasType{ n }{ \out{\tau} } } }
  }

  {
    \inferrule*
    [lab=\LookupEnv-Inductive-Eliminator-Here]
    {
      I =\Inductive{n}{\overline{p}}{\overline{i}}{u}{\overline{c}}
      \\
      v = \op{\text{EliminatorName}(} I \op{,\ } u_{e} \op{)}
      \and
      \tau = \op{\text{EliminatorType}(} I \op{,\ } u_{e} \op{)}
    }
    { \turnstile{ {\MathCons{I}{E}} }{ \hasType{ v }{ \out{\tau} } } }
  }

  {
    \inferrule*
    [lab=\LookupEnv-Constructor]
    {
      I =\Inductive{n_{\text{ind}}}{\overline{p_{\text{ind}}}}{\overline{i_{\text{ind}}}}{u}{
        \overline{c}
      }
      \\
      \exists\ C \in \overline{c} \text{\ such that\ }
      C = \Constructor{n_{\text{ctor}}}{\overline{p_{\text{ctor}}}}{\overline{i_{\text{ctor}}}}
      \\
      \tau = \op{\text{ConstructorType}(} I \op{,\ } C \op{,\ } u_{e} \op{)}
    }
    { \turnstile{ {\MathCons{I}{E}} }{ \hasType{ n_{\text{ctor}} }{ \out{\tau} } } }
  }

  {
    \inferrule*
    [lab=\LookupEnv-There]
    {
      I =\Inductive{n_{\text{ind}}}{\overline{p_{\text{ind}}}}{\overline{i_{\text{ind}}}}{u}{
        \overline{c}
      }
      \\\\
      v \neq n_{\text{ind}}
      \and
      \forall u_{e}, v \neq \op{\text{EliminatorName}(} I \op{,\ } u_{e} \op{)}
      \\
      \forall\ \Constructor{n_{\text{ctor}}}{\overline{p_{\text{ctor}}}}{\overline{i_{\text{ctor}}}}
      \in \overline{c}, v \neq n_{\text{ctor}}
      \\\\
      \turnstile{ E }{ \hasType{v}{\out{\tau}} }
    }
    { \turnstile{ {\MathCons{I}{E}} }{ \hasType{ v }{ \out{\tau} } } }
  }

\end{mathpar}

\end{Rules}

Our second notion of a lookup essentially follows the same strategy, but we are
\emph{\textbf{not}} interested in finding the type of the variable, but rather
in knowing \textbf{how} \emph{both} the binding \emph{and} the binding type have
been modified.  To do so, we use the following judgment:

{
  \[
    \turnstile
    {\dcontext {E} {\delta_E} {\Gamma} {\delta_\Gamma} }
    { \declDiff { v } { \delta_v } { \delta_{\tau} } }
  \]
}

\paragraph{Notation} This judgment can be read as follows:
\begin{itemize}

\item \textbf{Top}: If you are interested in the variable $v$, as bound in the
original global environment $E$ and original local context $\Gamma$,

\item \textbf{Bottom left}: and the global environment underwent modification
$\delta_{E}$,

\item \textbf{Bottom left}: and the local context underwent modification
$\delta_{\Gamma}$,

\item \textbf{Bottom right}: then, references to the variable must undergo
modification $\out{\delta_{v}}$,

\item \textbf{Bottom right}: and the variable's type has undergone modification
$\out{\delta_{\tau}}$.

\end{itemize}

The rules in Figure~\ref{lookup-diff-dispatch} summarize the global strategy of
first looking up in the local context, and then falling back to the global
environment, analogously to the process in Figure~\ref{lookup-type-dispatch}.

\begin{Rules}
  {lookup-diff-dispatch}
  { Diff lookup rules (local context and global environment) }

\begin{mathpar}
  {
    \inferrule*
    [lab=Diff-\LookupCtxt]
    {\turnstile%
      { \diff{\Gamma}{\delta_\Gamma} }
      { \declDiff{ v }{ \delta_v }{ \delta_{\tau} } }
    }
    {\turnstile%
      {\dcontext{E}{\delta_E}{\Gamma}{\delta_\Gamma} }
      { \declDiff{ v }{ \delta_v }{ \delta_{\tau} } }
    }
  }

  {
    \inferrule*
    [lab=Diff-\LookupEnv]
    {
      {\turnstile%
        { \diff{E} {\delta_E} }
        { \declDiff{ v } { \delta_v } { \delta_{\tau} } }
      }
    }
    {\turnstile%
      { \dcontext{E} {\delta_E} {\Gamma} {\delta_\Gamma} }
      { \declDiff{ v } { \delta_v } { \delta_{\tau} } }
    }
  }

\end{mathpar}

\end{Rules}

Figure~\ref{lookup-diff-context} shows how we proceed to lookup for the diff of
a variable from the original program in the local context.  Note that, since we
assume the original program type-checked, when we look up variables, we can
assume that they are properly bound: were it not the case, we would need
additional rules to account for the absence of a variable, and to change the
output types to allow for failure.

When the context hasn't changed, we can obtain its type from the old environment
(Rule~\rulename{Diff-\LCSame}).  When some variable has been inserted, we can
ignore it with no effort, since we only care about shadowing in the original
program (Rule~\rulename{Diff-\LCIns}).

When we find the target variable in the local context, there are only two
remaining possibilities for the diff: either it is a $\MathModPiOp$, or a
$\MathDropPiOp$.  When it has been modified, we have found exactly the
information we were looking for, so we can simply output it
(Rule~\rulename{Diff-\LCMod-Here}).  If it has been dropped, then there is no
satisfactory result, the variable is no longer in the program.  In order to make
sure the user notices, we rename the variable using the helper
$\op{\text{Deprecate}}$, and make its diff as uninformative as possible using a
hole (Rule~\rulename{Diff-\LCMod-There}).

The last case to handle (Rule~\rulename{Diff-\LCDrop}) is that of a variable
other than our target being modified, in which case we simply keep looking
recursively into the context.

\begin{Rules}{lookup-diff-context}{ Diff lookup rules (local context) }

  \begin{mathpar}
    {
      \inferrule*
      [lab=Diff-\LCSame]
      {
        { \turnstile {\Gamma} {\hasType { v } { \out{\tau_v} } } }
      }
      {\turnstile
        { \diff {\Gamma} {\MathSame} }
        { \declDiff { v } { \MathSame } { \MathSame } }
      }
    }

    {
      \inferrule*
      [lab=Diff-\LCIns]
      {\turnstile
        { \diff {\Gamma} {\delta_{\Gamma}} }
        { \declDiff { v } { \delta_v } { \delta_{\tau_v} } }
      }
      {\turnstile
        { \diff {\Gamma} {\MathIns{ (\delta_w : \delta_{\tau_{w}}) }{\delta_{\Gamma}}} }
        { \declDiff { v } { \delta_v } { \delta_{\tau_v} } }
      }
    }

    {
      \inferrule*
      [lab=Diff-\LCMod-Here]
      {
      }
      {\turnstile
        { \diff {\MathCons{\MathLocalAssum{v}{\tau}}{\Gamma}} {\MathMod{(\delta_v : \delta_{\tau})}{\delta_{\Gamma}}} }
        { \declDiff { v } { \delta_v } { \delta_{\tau} } }
      }
    }

    {
      \inferrule*
      [lab=Diff-\LCMod-There]
      {
        w \neq v
        \and
        {\turnstile
          { \diff {\Gamma} {\delta_{\Gamma}} }
          { \declDiff { v } { \delta_v } { \delta_{\tau} } }
        }
      }
      {\turnstile
        { \diff {\MathCons{\MathLocalAssum{w}{\tau}}{\Gamma}} {\MathMod{(\delta_v : \delta_{\tau})}{\delta_{\Gamma}}} }
        { \declDiff { v } { \delta_v } { \delta_{\tau} } }
      }
    }

    {
      \inferrule*
      [lab=Diff-\LCDrop]
      { v' = \op{\text{Deprecate}(} v \op{)}
      }
      {\turnstile%
        { \diff%
          { \MathCons{\MathLocalAssum{v}{\tau}}{\Gamma} }
          { \MathDrop{\delta_{\Gamma}} }
        }
        { \declDiff { v } { \MathReplace{v'} } { \MathReplace{\MathHole{}} } }
      }
    }

\end{mathpar}

\end{Rules}
