\section{Lookup rules}~\label{chick-lookup-rules}

When encountering a variable in a program under repair, we will often need to
answer the question ``What has happened to this variable?''.  In order to do so,
we generalize the usual notion of variable lookup.  In presentations of lambda
calculi where both a global environment and a local context carry typing
information, the usual notion of variable lookup first looks in the local
context (since it carries the ``closest'' enclosing scopes), then, if no binding
is found, looks in the global environment.


We use the following judgments for looking up a variable in the local context
$\Gamma$ (on the left), and in the global environment $E$ (on the
right):~\footnote{While the two judgments share the same syntax, it should
always be clear whether the value to the left of the turnstile is a local
context or a global environment.}

\[
  \turnstile{\Gamma}{ \hasType{ v }{ \out{\tau} } }
  \hspace{1cm}
  \turnstile{E}{ \hasType{ v }{ \out{\tau} } }
\]

\subsection{Lookup rules for types}

The rules for looking up types are straightforward, as shown in
Figures~\ref{lookup-type-dispatch},~\ref{lookup-type-context},
and~\ref{lookup-type-environment}.  In the latter, we handle the complexity of
inductive data type definitions.  For those, a system like \Coq{} will introduce
not only a name for the inductive type being defined, but also one name per
elimination principles it generates, and finally one name per the constructor of
the data type.  This is captured in the lookup rules, where we check those in
order before looking in the rest of the environment.  Unfortunately,
rule~\rulename{\LookupEnv-There} has to be quite bloated, but its premises only
ensure that we look in the rest of the environment only when neither of the
three previous rules hold.

\begin{Rules}{lookup-type-dispatch}{ Lookup rules (local context and global environment) }

\begin{mathpar}
  {
    \inferrule*
    [lab=\LookupCtxt]
    { \turnstile{ \Gamma }{ \hasType{ v }{ \out{\tau} } } }
    { \turnstile{ \context{E}{\ \Gamma} }{ \hasType{ v }{ \out{\tau} } } }
  }

  {
    \inferrule*
    [lab=\LookupEnv]
    {
      \nturnstile{ \Gamma }{ \hasType{ v }{ \out{\tau} } }
      \and
      \turnstile{ E }{ \hasType{ v }{ \out{\tau} } }
    }
    { \turnstile{ \context{E}{\ \Gamma} }{ \hasType{ v }{ \out{\tau} } } }
  }

\end{mathpar}

\end{Rules}

\begin{Rules}{lookup-type-context}{ Lookup rules (local context) }

\begin{mathpar}
  {
    \inferrule*
    [lab=\LookupCtxt-Here]
    {  }
    { \turnstile{ \MathCons{\MathLocalAssum{v}{\tau}}{\Gamma} }{ \hasType{ v }{ \out{\tau} } } }
  }

  {
    \inferrule*
    [lab=\LookupCtxt-There]
    { w \neq v \and \turnstile{ \Gamma }{ \hasType{ v }{ \out{\tau} } } }
    { \turnstile{ \MathCons{\MathLocalAssum{w}{\tau}}{\Gamma} }{ \hasType{ v }{ \out{\tau} } } }
  }

\end{mathpar}

\end{Rules}

\begin{Rules}{lookup-type-environment}{ Lookup rules (global environment) }

\begin{mathpar}
  {
    \inferrule*
    [lab=\LookupEnv-Definition-Here]
    {  }
    { \turnstile{ {\MathCons{\Definition{k}{v}{\tau}{t}}{E}} }{ \hasType{ v }{ \out{\tau} } } }
  }

  {
    \inferrule*
    [lab=\LookupEnv-Definition-There]
    { w \neq v \and \turnstile{ E }{ \hasType{ v }{ \out{\tau} } } }
    { \turnstile{ {\MathCons{\Definition{k}{w}{\tau}{t}}{E}} }{ \hasType{ v }{ \out{\tau} } } }
  }

  {
    \inferrule*
    [lab=\LookupEnv-Inductive-Type-Here]
    {
      {
        I = \Inductive%
        {n_{\text{ind}}}
        {\overline{p_{\text{ind}}}}
        {\overline{i_{\text{ind}}}}
        {u}
        {\overline{c}}
      }
      \\
      {
        \begin{cases}
          v = n_{ind}
          & \text{\ and\ } \op{\text{InductiveType}(} I \op{)} = \out{\tau} \\
          \text{\ or\ }\\
          \exists u_{\text{elim}} \text{\ such that\ } \\
          \quad v = \op{\text{EliminatorName}(} I \op{,\ } u_{\text{elim}} \op{)}
          & \text{\ and\ }
          \op{\text{EliminatorType}(} I \op{,\ } u_{\text{elim}} \op{)} = \out{\tau} \\
          \text{\ or\ }\\
          \exists\ C \in \overline{c} \text{\ such that\ } \\
          \quad C = \Constructor%
          {v}
          {\overline{p_{\text{ctor}}}}
          {\overline{i_{\text{ctor}}}}
          & \text{\ and\ }
          \op{\text{ConstructorType}(} I \op{,\ } C \op{)}
          = \out{\tau}
        \end{cases}
      }
    }
    { \turnstile{ {\MathCons{I}{E}} }{ \hasType{ v }{ \out{\tau} } } }
  }

  {
    \inferrule*
    [lab=\LookupEnv-There]
    {
      {
        I = \Inductive%
        {n_{\text{ind}}}
        {\overline{p_{\text{ind}}}}
        {\overline{i_{\text{ind}}}}
        {u}{\overline{c}}
      }
      \\
      {
        \begin{cases}
          v \neq n_{\text{ind}} & \\
          \text{\ and\ }\\
          \forall u_{\text{elim}},
          v \neq \op{\text{EliminatorName}(} I \op{,\ } u_{\text{elim}} \op{)}\\
          \text{\ and\ }\\
          \forall \Constructor%
          {n_{\text{ctor}}}
          {\overline{p_{\text{ctor}}}}
          {\overline{i_{\text{ctor}}}}
          \in \overline{c}, v \neq n_{\text{ctor}}
        \end{cases}
      }
      \\\\
      { \turnstile{ E }{ \hasType{v}{\out{\tau}} } }
    }
    { \turnstile{ {\MathCons{I}{E}} }{ \hasType{ v }{ \out{\tau} } } }
  }

\end{mathpar}

\end{Rules}

\subsection{Lookup rules for diffs}

Our second notion of a lookup essentially follows the same strategy, but we are
\emph{\textbf{not}} interested in finding the type of the variable, but rather
in knowing \textbf{how} \emph{both} the binding \emph{and} the binding type have
been modified.  To do so, we use the following judgment:

{
  \[
    \turnstile
    {\dcontext {E} {\delta_E} {\Gamma} {\delta_\Gamma} }
    { \declDiff { v } { \delta_v } { \delta_{\tau} } }
  \]
}

\paragraph{Notation} This judgment can be read as follows:
\begin{itemize}

\item \textbf{Top}: If you are interested in the variable $v$, as bound in the
original global environment $E$ and original local context $\Gamma$,

\item \textbf{Bottom left}: and the global environment underwent modification
$\delta_{E}$,

\item \textbf{Bottom left}: and the local context underwent modification
$\delta_{\Gamma}$,

\item \textbf{Bottom right}: then, references to the variable must undergo
modification $\out{\delta_{v}}$,

\item \textbf{Bottom right}: and the variable's type has undergone modification
$\out{\delta_{\tau}}$.

\end{itemize}

The rules in Figure~\ref{lookup-diff-dispatch} summarize the global strategy of
first looking up in the local context, and then falling back to the global
environment, analogously to the process in Figure~\ref{lookup-type-dispatch}.

\begin{Rules}
  {lookup-diff-dispatch}
  { Diff lookup rules (local context and global environment) }

\begin{mathpar}
  {
    \inferrule*
    [lab=Diff-\LookupCtxt]
    {\turnstile%
      { \diff{\Gamma}{\delta_\Gamma} }
      { \declDiff{ v }{ \delta_v }{ \delta_{\tau} } }
    }
    {\turnstile%
      {\dcontext{E}{\delta_E}{\Gamma}{\delta_\Gamma} }
      { \declDiff{ v }{ \delta_v }{ \delta_{\tau} } }
    }
  }

  {
    \inferrule*
    [lab=Diff-\LookupEnv]
    {
      {\turnstile%
        { \diff{E} {\delta_E} }
        { \declDiff{ v } { \delta_v } { \delta_{\tau} } }
      }
    }
    {\turnstile%
      { \dcontext{E} {\delta_E} {\Gamma} {\delta_\Gamma} }
      { \declDiff{ v } { \delta_v } { \delta_{\tau} } }
    }
  }

\end{mathpar}

\end{Rules}

\subsubsection{Lookup rules for diffs in the local context}

Figure~\ref{lookup-diff-context} shows how we proceed to lookup for the diff of
a variable from the original program in the local context.  Note that, since we
assume the original program type-checked, when we look up variables, we can
assume that they are properly bound: were it not the case, we would need
additional rules to account for the absence of a variable, and to change the
output types to allow for failure.

When the context hasn't changed, we can obtain its type from the old environment
(Rule~\rulename{Diff-\LCSame}).  When some variable has been inserted, we can
ignore it with no effort, since we only care about shadowing in the original
program (Rule~\rulename{Diff-\LCIns}).

When we find the target variable in the local context, there are only two
remaining possibilities for the diff: either it is a $\MathModPiOp$, or a
$\MathDropPiOp$.  When it has been modified, we have found exactly the
information we were looking for, so we can simply output it
(Rule~\rulename{Diff-\LCMod-Here}).  If it has been dropped, then there is no
satisfactory result, the variable is no longer in the program.  In order to make
sure the user notices, we rename the variable using the helper
$\op{\text{Deprecate}}$, and make its diff as uninformative as possible using a
hole (Rule~\rulename{Diff-\LCMod-There}).

The last cases to handle are that of a variable other than our target being
modified (Rule~\rulename{Diff-\LCDrop}), in which case we simply keep looking
recursively into the context, and that of a permutation
(Rule~\rulename{Diff-\LCPermute}), in which case we can perform the permutation
and keep looking recursively.

\begin{Rules}{lookup-diff-context}{ Diff lookup rules (local context) }

  \begin{mathpar}
    {
      \inferrule*
      [lab=Diff-\LCSame]
      {
        { \turnstile {\Gamma} {\hasType { v } { \out{\tau_v} } } }
      }
      {\turnstile
        { \diff {\Gamma} {\MathSame} }
        { \declDiff { v } { \MathSame } { \MathSame } }
      }
    }

    {
      \inferrule*
      [lab=Diff-\LCIns]
      {\turnstile
        { \diff {\Gamma} {\delta_{\Gamma}} }
        { \declDiff { v } { \delta_v } { \delta_{\tau_v} } }
      }
      {\turnstile
        { \diff {\Gamma} {\MathIns{ (\delta_w : \delta_{\tau_{w}}) }{\delta_{\Gamma}}} }
        { \declDiff { v } { \delta_v } { \delta_{\tau_v} } }
      }
    }

    {
      \inferrule*
      [lab=Diff-\LCMod-Here]
      {
      }
      {\turnstile
        { \diff {\MathCons{\MathLocalAssum{v}{\tau}}{\Gamma}} {\MathMod{(\delta_v : \delta_{\tau})}{\delta_{\Gamma}}} }
        { \declDiff { v } { \delta_v } { \delta_{\tau} } }
      }
    }

    {
      \inferrule*
      [lab=Diff-\LCMod-There]
      {
        w \neq v
        \and
        {\turnstile
          { \diff {\Gamma} {\delta_{\Gamma}} }
          { \declDiff { v } { \delta_v } { \delta_{\tau} } }
        }
      }
      {\turnstile
        { \diff {\MathCons{\MathLocalAssum{w}{\tau}}{\Gamma}} {\MathMod{(\delta_v : \delta_{\tau})}{\delta_{\Gamma}}} }
        { \declDiff { v } { \delta_v } { \delta_{\tau} } }
      }
    }

    {
      \inferrule*
      [lab=Diff-\LCDrop]
      { \op{\text{Deprecate}(} v \op{)} = \out{v'} }
      {\turnstile%
        { \diff%
          { \MathCons{\MathLocalAssum{v}{\tau}}{\Gamma} }
          { \MathDrop{\delta_{\Gamma}} }
        }
        { \declDiff { v } { \MathReplace{v'} } { \MathReplace{\MathHole{}} } }
      }
    }

    {
      \inferrule*
      [lab=Diff-\LCPermute]
      {\turnstile%
        { \diff%
          { \permuteOp{p}{\Gamma} }
          { \delta_{\Gamma} }
        }
        { \declDiff { v } { \delta_{v} } { \delta_{\tau} } }
      }
      {\turnstile%
        { \diff%
          { \Gamma }
          { \MathPermute{p}{\delta_{\Gamma}} }
        }
        { \declDiff { v } { \delta_{v} } { \delta_{\tau} } }
      }
    }

\end{mathpar}

\end{Rules}

\subsubsection{Lookup rules for diffs in the global environment}

Unfortunately, the number of combinations we need to consider for diffs grow
alongside the number of constructs that introduce variables, as well as along
the number of modifications that happen to those constructs.  Since inductive
data type definitions introduce three classes of variables (namely, the type,
the eliminators, and the constructors), and we have four classes of changes for
lists ($\MathSame{}$, $\MathMod{}{}$, $\MathDrop{}$, $\permuteOp{}{}$), this
raises the number of cases in a quadratic fashion.  We do our best to summarize
those cases in few rules, by using disjunctive premises to account for many
cases in a single rule.

Figure~\ref{rules-lookup-environment-same} covers the simplest cases.  When the
environment has not changed, as in Rule~\rulename{Diff-\GESame}, the variable
must not have changed either, as long as it actually existed.  When any
$\DefinitionText{}$ or $\InductiveText{}$ has been inserted, we can skip it and
keep looking recursively (Rule~\rulename{Diff-\GEIns}).  Finally, when the
environment has undergone a permutation, we can simply proceed recursively on
the appropriately permuted environment (Rule~\rulename{Diff-\GEPermute}).

\begin{Rules}
{rules-lookup-environment-same}
{Lookup in the global environment (identity, insertion, permutation)}

  \begin{mathpar}
    { % don't break this line or things get out of center
      \inferrule*
      [lab=Diff-\GESame]
      {
        { \turnstile {E} {\hasType { v } { \out{\tau_v} } } }
      }
      {\turnstile
        { \diff {E} {\MathSame} }
        { \declDiff { v } { \MathSame } { \MathSame } }
      }
    }

    {
      \inferrule*
      [lab=Diff-\GEIns]
      {\turnstile
        { \diff {E} {\delta_{E}} }
        { \declDiff { v } { \delta_v } { \delta_{\tau_v} } }
      }
      {\turnstile
        { \diff%
          {E}
          {
            \MathIns{e}{\delta_{E}}
          }
        }
        { \declDiff { v } { \delta_v } { \delta_{\tau_v} } }
      }
    }

    {
      \inferrule*
      [lab=Diff-\GEPermute]
      {\turnstile%
        { \diff%
          { \permuteOp{p}{E} }
          { \delta_{E} }
        }
        { \declDiff { v } { \delta_{v} } { \delta_{\tau} } }
      }
      {\turnstile%
        { \diff%
          { E }
          { \MathPermute{p}{\delta_{E}} }
        }
        { \declDiff { v } { \delta_{v} } { \delta_{\tau} } }
      }
    }

  \end{mathpar}
\end{Rules}

When an element has been removed from the environment
(Figure~\ref{rules-lookup-environment-drop}), we need to check whether the
variable in question has been removed or not.  For a $\DefinitionText{}$, it
suffices to check whether the name matches, but for an $\InductiveText{}$, we
need to check whether the name matches the inductive type, any of the
eliminators, or any of the constructors.  If it does, then we indicate that the
variable has been removed by using $\op{\text{Deprecate}}$ again
(Rule~\rulename{Diff-\GEDrop-Here}).  Otherwise, we keep looking recursively
(Rule~\rulename{Diff-\GEDrop-There}).

\begin{Rules}
{rules-lookup-environment-drop}
{Lookup in the global environment (drop)}

  \begin{mathpar}
    {
      \inferrule*
      [lab=Diff-\GEDrop-Here]
      {
        {
          \begin{cases}
            e = \Definition{k}{v}{\tau}{t} \\
            \text{\ or\ } \\
            e = \Inductive%
            {n_{\text{ind}}}
            {\overline{p_{\text{ind}}}}
            {\overline{i_{\text{ind}}}}
            {u}
            {\overline{c}}
            \text{\ and\ }\\
         \quad
        \begin{cases}
          v = n_{ind}\\
          \text{\ or\ }\\
          \exists u_{\text{elim}} \text{\ such that\ }
          v = \op{\text{EliminatorName}(} e \op{,\ } u_{\text{elim}} \op{)}\\
          \text{\ or\ }\\
          \exists\ C \in \overline{c} \text{\ such that\ }
          C = \Constructor%
          {v}
          {\overline{p_{\text{ctor}}}}
          {\overline{i_{\text{ctor}}}}
        \end{cases}
          \end{cases}
        }
        \\
        {
          \op{\text{Deprecate}(} v \op{)} = \out{v'}
        }
      }
      {
        \turnstile%
        { \diff%
          {
            \MathCons%
            {e}
            {E}
          }
          {\MathDrop{\delta_{E}}} }
        { \declDiff{v}{\MathReplace{v'}}{\MathReplace{\MathHole{}}} }
      }
    }

    {
      \inferrule*
      [lab=Diff-\GEDrop-There]
      {
        {
          \begin{cases}
            e = \Definition{k}{w}{\tau}{t} \text{\ and\ } v \neq w \\
            \text{\ or\ } \\
            e = \Inductive%
            {n_{\text{ind}}}
            {\overline{p_{\text{ind}}}}
            {\overline{i_{\text{ind}}}}
            {u}
            {\overline{c}}
            \text{\ and\ }\\
            \quad
            \begin{cases}
            v \neq n_{\text{ind}} & \\
            \text{\ and\ }\\
            \forall u_{\text{elim}},
            v \neq \op{\text{EliminatorName}(} e \op{,\ } u_{\text{elim}} \op{)}\\
            \text{\ and\ }\\
            \forall \Constructor%
            {n_{\text{ctor}}}
            {\overline{p_{\text{ctor}}}}
            {\overline{i_{\text{ctor}}}}
            \in \overline{c}, v \neq n_{\text{ctor}}
          \end{cases}
          \end{cases}
        }
        \\
        {
          \turnstile%
          { \diff%
            {E}
            {\delta_{E}}
          }
          { \declDiff{v}{\delta_v}{\delta_\tau} }
        }
      }
      {
        \turnstile%
        { \diff%
          {
            \MathCons%
            {e}
            {E}
          }
          {\MathDrop{\delta_{E}}} }
        { \declDiff{v}{\delta_v}{\delta_\tau} }
      }
    }
  \end{mathpar}
\end{Rules}

\begin{Rules}
{rules-lookup-environment-mod}
{Lookup in the global environment (modification)}

  \begin{mathpar}
    { % don't break this line or things get out of center
      \inferrule*
      [lab=Diff-\GEMod{Defn}]
      {
        {
          \begin{cases}
            \begin{cases}
              e = \Definition{k}{v}{\tau}{t} \\
              \delta_{e} = \ModifyDefinition{\delta_k}{\delta_v}{\delta_\tau}{\delta_t}
            \end{cases} \\
            C
          \end{cases}
        }
      }
      {\turnstile
        { \diff
          {\MathCons{\Definition{k}{v}{\tau}{t}}{E}}
          {\MathMod{\ModifyDefinition{\delta_k}{\delta_v}{\delta_\tau}{\delta_t}}{\delta_{E}}}
        }
        { \declDiff { v } { \delta_v } { \delta_{\tau} } }
      }
    }

    {
      \inferrule*
      [lab=Diff-\GEMod{Inductive}-Type]
      {
        {
          I = \Inductive%
          {n}
          {\overline{p}}
          {\overline{i}}
          {u}
          {\overline{c}}
        }
        \\
        {
          \delta_{I} = \ModifyInductive%
          {\delta_n}
          {\delta_{\overline{p}}}
          {\delta_{\overline{i}}}
          {\delta_u}
          {\delta_{\overline{c}}}
        }
        \\\\
        {
          \deltaIndType{I}{\delta_{I}}{\delta_\tau}
        }
      }
      {
        \turnstile%
        {
          \diff%
          {\MathCons{I}{E}}
          {
            \MathMod%
            {\delta_{I}}
            {\delta_{E}}
          }
        }
        { \declDiff{n}{\delta_n}{\delta_{\tau}} }
      }
    }

    % {
    %   \inferrule*
    %   [lab=Diff-\GEMod{Inductive}]
    %   { T
    %   }
    %   { B
    %   }
    % }

    {
      \inferrule*
      [lab=Diff-\GEMod{Eliminator}]
      {
        {
          I = \Inductive%
          {n}
          {\overline{p}}
          {\overline{i}}
          {u}
          {\overline{c}}
        }
        \\
        {
          \delta_{I} = \ModifyInductive%
          {\delta_n}
          {\delta_{\overline{p}}}
          {\delta_{\overline{i}}}
          {\delta_u}
          {\delta_{\overline{c}}}
        }
        \\\\
        {
          v = \op{\text{EliminatorName}(} I \op{,\ } u_{\text{elim}} \op{)}
        }
        \and
        {
          \deltaEliminatorName{I}{\delta_{I}}{u_{\text{elim}}}
          {\delta_v}
        }
        \\
        {
          \deltaEliminator{I}{\delta_{I}}{u_{\text{elim}}}
          {\delta_\tau}
        }
      }
      {\turnstile%
        { \diff%
          {\MathCons{I}{E}}
          {\MathMod{\delta_{I}}{\delta_{E}}}
        }
        { \declDiff{v}{\delta_v}{\delta_{\tau}} }
      }
    }

  \end{mathpar}

\end{Rules}

TODO

\begin{Rules}
{rules-lookup-environment-constructor}
{Lookup in the global environment (constructor rules)}

  \begin{mathpar}
    % Possibilities:
    % (v + cs), (δv +mod δcs)
    % (v + cs), (-drop δcs)
    % (v + cs), (+keep δcs)
    % (v + cs), (permute p δcs)
    % (v + cs), (v' +ins δcs)
    % (v' + cs), (δv +mod δcs)
    % (v' + cs), (-drop δcs)
    % (v' + cs), (+keep δcs)
    % (v' + cs), (permute p δcs)
    % (v' + cs), (v'' +ins δcs)
    {
      \inferrule*
      [lab=Diff-\GEMod{Constructor}]
      {
        {
          I = \Inductive%
          {n}
          {\overline{p}}
          {\overline{i}}
          {u}
          {\MathCons{C}{\overline{c}}}
        }
        \\
        {
          \delta_{I} = \ModifyInductive%
          {\delta_n}
          {\delta_{\overline{p}}}
          {\delta_{\overline{i}}}
          {\delta_u}
          {\delta_{\overline{c}}}
        }
        \\
        {
          C = \Constructor%
          {n_{\text{ctor}}}
          {\overline{p_{\text{ctor}}}}
          {\overline{i_{\text{ctor}}}}
        }
        \\
        {
          \deltaConstructor
          {\overline{p}}
          {\delta_{\overline{p}}}
          {\overline{i}}
          {\delta_{\overline{i}}}
          {\overline{c}}
          {\delta_{\overline{c}}}
          {v}
          {(\delta_v, \delta_\tau)}
        }
      }
      {\turnstile
        { \diff
          {\MathCons
            {\Inductive
              {n}
              {\overline{p}}
              {\overline{i}}
              {u}
              {\overline{c}}
            }
            {E}
          }
          {\MathMod
            {\ModifyInductive
              {\delta_n}
              {\delta_{\overline{p}}}
              {\delta_{\overline{i}}}
              {\delta_u}
              {\delta_{\overline{c}}}
            }
            {\delta_{E}}
          }
        }
        { \declDiff{v}{\delta_v}{\delta_{\tau}} }
      }
    }

  \end{mathpar}

\end{Rules}
