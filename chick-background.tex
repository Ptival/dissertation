\section{Background}

Programs are rarely written once and for all: bugs may be found that must be
fixed, requirements may evolve in ways that require rewriting parts of a
program, and programs may be re-written in semantically-equivalent ways in order
to account for performance, resource-efficiency, or even simply stylistic
concerns.

The concept of \define{refactoring}, which was introduced as early as
in~\citet{wirfs1990surveying}, characterizes program transformations that
preserve the semantics of the program being manipulated.

% TODO FIXME

\begin{figure*}[!htp]

  \noindent%
  \begin{minipage}[t]{0.50\textwidth}
    \begin{minted}[fontsize=\footnotesize,linenos=false]{coq}
Inductive nat : Set :=
| O : nat
| S : ∀ (n : nat), nat.

Inductive list (A : Type)
: Type :=
| nil : list A
| cons : A →
    list A → list A.

Definition a_list
: list nat :=
  cons nat (S O)
    (nil nat).

Definition length :
  ∀ (T : Type),
    list T → nat :=
  λ T l, list_rect T (λ _, nat) O
    (λ _ _ lt, S lt) l.

Fixpoint map :
  ∀ (A B : Type), (A → B) →
    list A →
    list B :=
  λ _ B f l,
    match l with
    | nil _      => nil B
    | cons _ h t =>
      cons B (f h) (map A B f t)
    end.
  \end{minted}
\end{minipage}%
\begin{minipage}[t]{0.50\textwidth}
  \begin{minted}[fontsize=\footnotesize,escapeinside=@@,linenos=false]{coq}
Inductive nat : Set :=
| O : nat
| S : ∀ (n : nat), nat.

Inductive @\modified{vec}@ (A : Type)
: @\modified{nat →}@ Type :=
| @\modified{vnil}@ : @\modified{vec}@ A @\modified{O}@
| @\modified{vcons}@ : A → @\modified{∀ (n : nat),}@
    @\modified{vec}@ A @\modified{n}@ → @\modified{vec}@ A @\modified{(S n)}@.

Definition a_list
: @\repaired{vec}@ nat @\repaired{(\_ : nat)}@ :=
  @\repaired{vcons}@ nat @\repaired{(\_ : nat)}@ (S O)
    (nil nat).

Definition length :
  ∀ (T : Type),
    @\repaired{vec}@ T @\repaired{(\_ : nat)}@ → nat :=
  λ T l, @\repaired{vec\_rect}@ T (λ _, nat) O
    (λ _ _ lt, S lt) l.

Fixpoint map :
  ∀ (A B : Type), (A → B) →
    @\repaired{vec}@ A @\repaired{(\_ : nat)}@ →
    @\repaired{vec}@ B @\repaired{(\_ : nat)}@ :=
  λ _ B f l,
    match l with
    | nil _         => nil B
    | @\repaired{vcons}@ _ @\repaired{\_}@ h t =>
      @\repaired{vcons}@ B @\repaired{\_}@ (f h) (map A B f t)
    end.
  \end{minted}
\end{minipage}

\caption[Chick: example of a program repair]{ We demonstrate the propagation of
repairs after an inductive definition is modified.  On the left, the original
program.  On the right, we highlight the user-modified parts in yellow.  The
computed repairs are highlighted in green. }

\label{listtovec}

\end{figure*}
