\section{Guessing diffs}~\label{chick-guess}

We showed how our algorithm could take an initial program, and a diff describing
how to obtain the partial refactoring, in order to generate a repaired diff with
the refactoring carried out.  However, we had postponed the discussion of how
this original diff was obtained.

Automatically generating this diff turns out to be a hard problem.  It is
equivalent to the tree difference problem: given two abstract syntax trees, we
want to find a mapping of pairs of nodes from the old tree and the new tree,
such that we have high confidence that they are related nodes.

There is a bit of literature on the subject.  We chose to use the
\define{GumTree} algorithm, for two reasons.  First, its has a worst-case time
complexity of $O(n^{2})$, where the worst time is unlikely to happen in real
abstract syntax trees.  Second, it works by ranking candidate pairs according to
some heuristic similarity metric, which is useful in order to compute not just
the most likely answer, but, possibly, a list of likely answers ranked by the
heuristic likelihood.

Unfortunately, our early attempts of using the algorithm with our data types
proved unsuccessful.  Let us illustrate where the algorithm fails in our
setting, by first giving a broad overview of how it works:

\begin{itemize}

  \item First, all leaves are distinguished based on their identity.  In our
figures, we will denote nodes that are considered similar using colors.  After
this first pass, all leaves should be colored, such that they are similar to
equal leaves.

  \item Then, all pairs of old internal nodes and new internal nodes are
compared (in an efficient order) for similarity of their children.  The
similarity $S$ between two nodes is defined in Figure~\ref{similarity}, and
ranges between 0 (no shared children) to 1 (all children are shared).  Note that
it does not account for the order of the children.

  \item As items are found to be similar, they are added to a relation $n_{1}
\approx n_{2}$.  A custom threshold allows us to tweak how similar two nodes
need to be in order for our algorithm to consider them similar.  Then, remaining
pairs of nodes are considered by decreasing similarity, and added to the same
relation.

\end{itemize}

\begin{figure}
\centering
\[
    \text{S}(n_{1}, n_{2}) =
    \frac
    { 2 \times \bigm| \{ c_{1} \in C(n_{1}) \text{ such that } \exists c_{2} \in C(n_{2}), c_{1} \approx c_{2} \} \bigm| }
    { \bigm| \{ c \in C(n_{1}) \} \bigm| + \bigm| \{ c \in C(n_{2}) \} \bigm| }
\]

where $C(n)$ is the set of children of $n$
\\
and $c_{1} \approx c_{2}$ means that $c_{1}$ is considered similar to $c_{2}$
\caption{Similarity between two nodes}~\label{similarity}
\end{figure}

Let us now see where this algorithm underperforms in our setting.  Consider the
abstract syntax trees in Figure~\ref{chick-sub-trees-equal-similarity}.  In it,
we highlight three identical sub-trees, $T_{1}$, $T_{2}$, and $T_{3}$, in red
dashed rounded rectangles.  Due to being exactly the same sub-trees, their
similarity score will be equal.  Yet, to a human being, $T_{2} \approx T_{3}$
seems more likely than $T_{1} \approx T_{3}$: they are roughly in a similar
location in the abstract syntax tree.

\begin{figure}[htp!]
\centering
\begin{forest}
[,phantom
  [→
    [→
      [A,fill=color01]
      [→,name=spec n1,tikz={
        \node[RoundedRectangle,red,fit=()(!1)(!l)](T1){};
        \node[below=1pt of T1]{$T_{1}$};
        \node[NodeLabel] at (spec n1.south east) {$l_{1}$};
        }
        [C,fill=color02]
        [D,fill=color03]
      ]
    ]
    [→
      [A,fill=color01]
      [→,name=spec n2,tikz={
        \node[RoundedRectangle,red,fit=()(!1)(!l)](T2){};
        \node[below=1pt of T2]{$T_{2}$};
        \node[NodeLabel] at (spec n2.south east) {$l_{2}$};
      }
        [C,fill=color02]
        [D,fill=color03]
      ]
    ]
  ]
  [,phantom[,phantom[,phantom]]]
  [→
    [→
      [C,fill=color02]
      [→
        [B]
        [→
          [A,fill=color01]
          [D,fill=color03]
        ]
      ]
    ]
    [→
      [A,fill=color01]
      [→
        [B]
        [→,name=spec n3,tikz={
          \node[RoundedRectangle,red,fit=()(!1)(!l)](T3){};
          \node[below=1pt of T3]{$T_{3}$};
          \node[NodeLabel] at (spec n3.south east) {$r$};
          }
          [C,fill=color02]
          [D,fill=color03]
        ]
      ]
    ]
  ]
]
\end{forest}
\[
  S(l_{1},r) = 1 \hspace{2cm} S(l_{2},r) = 1
\]
\caption{Example of sub-trees with equal similarity}\label{chick-sub-trees-equal-similarity}
\end{figure}

In order to improve the algorithm's detection of such cases, we modify our
abstract syntax trees by ``squashing'' sequences of binary operators together
into n-ary nodes.  We show how this affects the same two trees in
Figure~\ref{chick-squashed-telescopes}.  Thanks to the squashing, the four
internal nodes $l_{1}$, $l_{2}$, $r_{1}$, and $r_{2}$ now display different
similarities with each other.  The algorithm will now consider that $l_{2}$ and
$r_{2}$ are most likely to be similar, and mark them as such.

\begin{figure}[htp!]
\centering
\begin{forest}
  [→,name=spec l1,tikz={
      \node[NodeLabel] at (spec l1.south east) {$l_{1}$};
      }
    [→,name=spec l2,tikz={
      \node[NodeLabel] at (spec l2.south east) {$l_{2}$};
      }
      [A,fill=color01]
      [C,fill=color02]
      [D,fill=color03]
    ]
    [A,fill=color01]
    [C,fill=color02]
    [D,fill=color03]
  ]
\end{forest}
\hspace{10pt}
\begin{forest}
  [→,name=spec r1,tikz={
      \node[NodeLabel] at (spec r1.south east) {$r_{1}$};
      }
    [→,name=spec r2,tikz={
      \node[NodeLabel] at (spec r2.south east) {$r_{2}$};
      }
      [C,fill=color02]
      [B]
      [A,fill=color01]
      [D,fill=color03]
    ]
    [A,fill=color01]
    [B]
    [C,fill=color02]
    [D,fill=color03]
  ]
\end{forest}
\begin{align*}
  S(l_{1},r_{1}) = \frac{6}{9} = 0.67 & \hspace{2cm} & S(l_{1},r_{2}) = \frac{6}{8} = 0.75\\
  S(l_{2},r_{1}) = \frac{6}{8} = 0.75 & \hspace{2cm} & S(l_{2},r_{2}) = \frac{6}{7} = 0.86\\
\end{align*}
\caption{Example of squashed telescopes}\label{chick-squashed-telescopes}
\end{figure}

Once this is done, it will recompute similarities for the remaining, unmatched
internal nodes.  Here, $l_{1}$ and $r_{1}$, the only remaining nodes, will now
have an increased similarity of $\frac{8}{9}$, or $0.89$, due to $l_{2}$ and
$r_{2}$ being considered similar.  This should exceed our custom threshold and
allow these nodes to be considered similar, resulting in the matching shown in
Figure~\ref{chick-guess-squashed-result}.

\begin{figure}[htp!]
\centering
\begin{forest}
  [→,fill=color05
    [→,fill=color04
      [A,fill=color01]
      [C,fill=color02]
      [D,fill=color03]
    ]
    [A,fill=color12]
    [C,fill=color13]
    [D,fill=color14]
  ]
\end{forest}
\hspace{10pt}
\begin{forest}
  [→,fill=color05
    [→,fill=color04
      [C,fill=color02]
      [B]
      [A,fill=color01]
      [D,fill=color03]
    ]
    [A,fill=color12]
    [B]
    [C,fill=color13]
    [D,fill=color14]
  ]
\end{forest}
\caption{Guess for matching with squashed telescopes}\label{chick-guess-squashed-result}
\end{figure}

However, we now need to unsquash the tree and figure out the proper relationship
between the previously squashed nodes.  This yields the syntax trees as shown in
Figure~\ref{chick-unsquashed-unresolved}, where several nodes share the same
coloring.  In order to produce a diff, we would like to have unique pairings
between the two trees.

\begin{figure}[htp!]
\centering
\begin{forest}
[,phantom
  [→,fill=color05
    [→,fill=color04
      [A,fill=color01]
      [→,fill=color04,tikz={\node[RoundedRectangle,color04,fit=()(!u)]{};}
        ,tikz={\draw[RoundedDottedPath,color04]
          (.north east) -- (!u.north east)
          -- (!u.north west) -- (!u.south west)
          -- (.south west) -- (.south east) -- (.north east)
          ;}
        [C,fill=color02]
        [D,fill=color03]
      ]
    ]
    [→,fill=color05
      [A,fill=color12]
      [→,fill=color05,tikz={\node[RoundedRectangle,color05,fit=()(!u)(!uu)]{};}
        ,tikz={\draw[RoundedDottedPath,color05]
          (.north east) -- (!u.north east) -- (!uu.north east)
          -- (!uu.north west) -- (!uu.south west) -- (!u.south west)
          -- (.south west) -- (.south east) -- (.north east)
          ;}
        [C,fill=color13]
        [D,fill=color14]
      ]
    ]
  ]
  [,phantom[,phantom[,phantom]]]
  [→,fill=color05
    [→,fill=color04
      [C,fill=color02]
      [→,fill=color04
        [B]
        [→,fill=color04,tikz={\node[RoundedRectangle,color04,fit=()(!u)(!uu)]{};}
        ,tikz={\draw[RoundedDottedPath,color04]
          (.north east) -- (!u.north east) -- (!uu.north east)
          -- (!uu.north west) -- (!uu.south west) -- (!u.south west)
          -- (.south west) -- (.south east) -- (.north east)
          ;}
          [A,fill=color01]
          [D,fill=color03]
        ]
      ]
    ]
    [→,fill=color05
      [A,fill=color12]
      [→,fill=color05
        [B]
        [→,fill=color05,tikz={\node[RoundedRectangle,color05,fit=()(!u)(!uu)(!uuu)]{};}
        ,tikz={\draw[RoundedDottedPath,color05]
          (.north east) -- (!u.north east) -- (!uu.north east) -- (!uuu.north east)
          -- (!uuu.north west) -- (!uuu.south west) -- (!uu.south west) -- (!u.south west)
          -- (.south west) -- (.south east) -- (.north east)
          ;}
          [C,fill=color13]
          [D,fill=color14]
        ]
      ]
    ]
  ]
]
\end{forest}
\caption{Guess for matching unsquashed, unresolved}\label{chick-unsquashed-unresolved}
\end{figure}

Since \coqinline{→} is a right-associative operation, we resolve the pairings by
comparing the left children of the remaining nodes first, then by comparing
similarity on the remaining nodes.  This yields our final guess, as shown on
Figure~\ref{chick-unsquashed-resolved}.  The outlines highlight those nodes we
considered similar due to their left child.  The root nodes have different left
children, but their similarity is $\frac{1}{2}$, or $0.5$, due to having similar
right children, so they are also considered similar.

\begin{figure}[htp!]
\centering
\begin{forest}
[,phantom
  [→,fill=color06
    [→,fill=color07
    ,tikz={\draw[RoundedDottedPath,bicolor={color07}{color01}]
      (.south east) -- (.north east) -- (.north west) -- (!1.north west) -- (!1.south west)
      -- (!1.south east) -- (.south east)
      ;}
      [A,fill=color01]
      [→,fill=color08
      ,tikz={\draw[RoundedDottedPath,bicolor={color08}{color02}]
        (.south east) -- (.north east) -- (.north west) -- (!1.north west) -- (!1.south west)
        -- (!1.south east) -- (.south east)
        ;}
        [C,fill=color02]
        [D,fill=color03]
      ]
    ]
    [→,fill=color09
    ,tikz={\draw[RoundedDottedPath,bicolor={color09}{color12}]
      (.south east) -- (.north east) -- (.north west) -- (!1.north west) -- (!1.south west)
      -- (!1.south east) -- (.south east)
      ;}
      [A,fill=color12]
      [→,fill=color10
      ,tikz={\draw[RoundedDottedPath,bicolor={color10}{color13}]
        (.south east) -- (.north east) -- (.north west) -- (!1.north west) -- (!1.south west)
        -- (!1.south east) -- (.south east)
        ;}
        [C,fill=color13]
        [D,fill=color14]
      ]
    ]
  ]
  [,phantom[,phantom[,phantom]]]
  [→,fill=color06
    [→,fill=color08
      ,tikz={\draw[RoundedDottedPath,bicolor={color08}{color02}]
        (.south east) -- (.north east) -- (.north west) -- (!1.north west) -- (!1.south west)
        -- (!1.south east) -- (.south east)
        ;}
      [C,fill=color02]
      [→
        [B]
        [→,fill=color07
        ,tikz={\draw[RoundedDottedPath,bicolor={color07}{color01}]
          (.south east) -- (.north east) -- (.north west) -- (!1.north west) -- (!1.south west)
          -- (!1.south east) -- (.south east)
          ;}
          [A,fill=color01]
          [D,fill=color03]
        ]
      ]
    ]
    [→,fill=color09
    ,tikz={\draw[RoundedDottedPath,bicolor={color09}{color12}]
      (.south east) -- (.north east) -- (.north west) -- (!1.north west) -- (!1.south west)
      -- (!1.south east) -- (.south east)
      ;}
      [A,fill=color12]
      [→
        [B]
        [→,fill=color10
        ,tikz={\draw[RoundedDottedPath,bicolor={color10}{color13}]
          (.south east) -- (.north east) -- (.north west) -- (!1.north west) -- (!1.south west)
          -- (!1.south east) -- (.south east)
          ;}
          [C,fill=color13]
          [D,fill=color14]
        ]
      ]
    ]
  ]
]
\end{forest}
\caption{Guess for matching unsquashed, resolved}\label{chick-unsquashed-resolved}
\end{figure}

Now that we have identified similar nodes between the old tree and the new tree,
the final step is to build an actual diff from this information.  The algorithm
is a fairly straightforward tree recursion.  We highlight how it works on three
relevant examples.

% \begin{figure}[htp!]
% \centering
% \begin{align*}
% \MatchingToDiff (
% \begin{forest}
%   begin draw/.code={\begin{tikzpicture}[baseline=(current bounding box.center)]},
%     [→,fill=color06
%       [→,fill=color07,for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}}
%         [,phantom]
%       ]
%       [→,fill=color09,for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}}
%         [,phantom]
%       ]
%     ]
% \end{forest},
% \begin{forest}
%   begin draw/.code={\begin{tikzpicture}[baseline=(current bounding box.center)]},
%     [→,fill=color06
%       [→,fill=color08,for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}}
%         [,phantom]
%       ]
%       [→,for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}}
%         [,phantom]
%       ]
%     ]
%   ]
% \end{forest}
% ) = \MathModPi%
% {
%   \MatchingToDiff{}(
%   \begin{forest}
%     begin draw/.code={\begin{tikzpicture}[anchor=base,baseline]},
%     [→,fill=color07]
%   \end{forest},
%   \begin{forest}
%     begin draw/.code={\begin{tikzpicture}[anchor=base,baseline]},
%     [→,fill=color09]
%   \end{forest}
%   )
% }
% {\MathSame{}}
% {
%   \MatchingToDiff{}(
%   \begin{forest}
%     begin draw/.code={\begin{tikzpicture}[anchor=base,baseline]},
%     [→,fill=color08]
%   \end{forest},
%   \begin{forest}
%     begin draw/.code={\begin{tikzpicture}[anchor=base,baseline]},
%     [→,fill=color10]
%   \end{forest}
%   )
% }
% \end{align*}
% \caption{Run of the algorithm for turning a matching into a diff}\label{chick-guess-to-diff}
% \end{figure}

\paragraph{Example 1} When the nodes on either side are equal, as is the case
with the root nodes of the two trees we've been considering so far, we can
\textbf{keep} the node (here, a $\Pi$ node, using $\MathModPiOp{}$), and
recursively compute the diffs between its sub-trees.  This is shown in
Figure~\ref{chick-guess-to-diff-1}.

\begin{figure}[htp!]
\centering
\begin{forest}
  [,phantom,tikz={\draw[Matching] (!1) -- (!l);},
    [→,fill=color06,
       tikz={\node[NodeLabel] at (.south east) {L};},
      [→,fill=color07,
         tikz={\node[NodeLabel] at (.south east) {L};},
         for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}},
         [...,draw=none]
         [...,draw=none]
      ]
      [→,fill=color09,for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}},
         tikz={\node[NodeLabel] at (.south east) {L};},
         [...,draw=none]
         [...,draw=none]
      ]
    ]
    [,phantom[,phantom[,phantom]]]
    [→,fill=color06,
       tikz={\node[NodeLabel] at (.south east) {R};},
      [→,fill=color08,for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}},
         tikz={\node[NodeLabel] at (.south east) {R};},
         [...,draw=none]
         [...,draw=none]
      ]
      [→,for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}},
         tikz={\node[NodeLabel] at (.south east) {R};},
         [...,draw=none]
         [...,draw=none]
      ]
    ]
  ]
\end{forest}
\\
\vspace{20pt}
$\delta(
\begin{forest}
  begin draw/.code={\begin{tikzpicture}[anchor=base,baseline]},
    [→,fill=color06,tikz={\node[NodeLabel] at (.south east) {L};},]
  \end{forest}
  ,
  \begin{forest}
    begin draw/.code={\begin{tikzpicture}[anchor=base,baseline]},
      [→,fill=color06,tikz={\node[NodeLabel] at (.south east) {R};},]
  \end{forest}
  )
= \out{
  \MathModPi
  {
    \textcolor{black}{\delta(
    \begin{forest}
      begin draw/.code={\begin{tikzpicture}[anchor=base,baseline]},
        [→,fill=color07,tikz={\node[NodeLabel] at (.south east) {L};},]
    \end{forest}
    ,
    \begin{forest}
      begin draw/.code={\begin{tikzpicture}[anchor=base,baseline]},
        [→,fill=color08,tikz={\node[NodeLabel] at (.south east) {R};},]
    \end{forest}
    )}
  }
  {\MathSame{}}
  {
    \textcolor{black}{\delta(
    \begin{forest}
      begin draw/.code={\begin{tikzpicture}[anchor=base,baseline]},
        [→,black,fill=color09,tikz={\node[NodeLabel] at (.south east) {L};},]
    \end{forest}
    ,
    \begin{forest}
      begin draw/.code={\begin{tikzpicture}[anchor=base,baseline]},
        [→,black,tikz={\node[NodeLabel] at (.south east) {R};},]
    \end{forest}
    )}
  }
}
$
\caption{Run of the algorithm for turning a matching into a diff (example 1)}\label{chick-guess-to-diff-1}
\end{figure}

\paragraph{Example 2} When the nodes on either side are \textbf{not} equal, as
is the case with the left sub-trees of the trees we previously considered, we
must figure out whether the node on the left has been removed, or moved around,
and if the node on the right has been added, or moved around.  This is shown in
Figure~\ref{chick-guess-to-diff-2}.  In this case, the left node has a similar
node in the right sub-tree, \textbf{and} the right node has a similar node in
the left sub-tree.  In order to resolve this crossing of nodes, we must
introduce a \textbf{permutation}.  Our algorithm figures out a minimal
permutation that will re-order all the nodes in the left telescope, such that
all such crossings are resolved at once.  In this case, the permutation is
simply switching the first and second elements of the telescope, indicated by
the permutation $\MathPermutePis{[1, 0]}$.  We then proceed recursively with the
permuted tree on the left, and the exact same tree on the right.

\begin{figure}[htp!]
\centering
\begin{forest}
  [,phantom,tikz={
    \draw[Matching,color07] (!1) -- (!lll);
    \draw[Matching,color08] (!1l) -- (!l);
  },
    [→,fill=color07,
       tikz={
         \draw[RoundedDottedPath,color07]
         (.south east) -- (.north east) -- (.north west) -- (!1.north west) -- (!1.south west)
         -- (!1.south east) -- (.south east)
         ;
         \node[NodeLabel] at (.south east) {L};
       },
      [A,for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}},
      ]
      [→,fill=color08,
         tikz={
           \draw[RoundedDottedPath,color08]
           (.south east) -- (.north east) -- (.north west) -- (!1.north west) -- (!1.south west)
           -- (!1.south east) -- (.south east)
          ;
          \node[NodeLabel] at (.south east) {L};
        },
         for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}},
        [C]
        [D]
      ]
    ]
    [,phantom[,phantom[,phantom]]]
    [→,fill=color08,
       tikz={\node[NodeLabel] at (.south east) {R};},
       [C,for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}},
       ]
       [→,for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}},
          tikz={\node[NodeLabel] at (.south east) {R};},
         [B]
         [→,fill=color07,
           [A]
           [D]
         ]
       ]
    ]
  ]
\end{forest}
\\
\vspace{20pt}
$\delta(
\begin{forest}
  begin draw/.code={\begin{tikzpicture}[anchor=base,baseline]},
    [→,fill=color07,tikz={\node[NodeLabel] at (.south east) {L};},]
  \end{forest}
  ,
  \begin{forest}
    begin draw/.code={\begin{tikzpicture}[anchor=base,baseline]},
      [→,fill=color08,tikz={\node[NodeLabel] at (.south east) {R};},]
  \end{forest}
  )
= \out{
  \MathPermutePis{[1,0]}
  {
    \textcolor{black}{\delta(
    \begin{forest}
      begin draw/.code={\begin{tikzpicture}[anchor=base,baseline]},
        [→,fill=color08,
           tikz={
             \draw[RoundedDottedPath,color08]
             (.south east) -- (.north east) -- (.north west) -- (!1.north west) -- (!1.south west)
             -- (!1.south east) -- (.south east)
             ;
             \node[NodeLabel] at (.south east) {L};
           },
           [C,for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}},
           ]
           [→,fill=color07,
             for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}},
             tikz={
               \draw[RoundedDottedPath,color07]
               (.south east) -- (.north east) -- (.north west) -- (!1.north west) -- (!1.south west)
               -- (!1.south east) -- (.south east)
               ;
               \node[NodeLabel] at (.south east) {L};
             },
            [A]
            [D]
          ]
        ]
    \end{forest}
    ,
    \begin{forest}
      begin draw/.code={\begin{tikzpicture}[anchor=base,baseline]},
        [→,fill=color08,tikz={\node[NodeLabel] at (.south east) {R};},]
    \end{forest}
    )}
  }
}
$
\caption{Run of the algorithm for turning a matching into a diff (example 2)}\label{chick-guess-to-diff-2}
\end{figure}

\paragraph{Example 3} Another case where the nodes considered do not match each
other is shown in Figure~\ref{chick-guess-to-diff-3}.  There, the right sub-tree
contains a matching node for the left node, but the left sub-tree does
\textbf{not} contain a matching node for the right node.  This tells us that the
right node must have been \textbf{inserted}.  We output an insertion with
$\MathInsPiOp{}$, and recursively process the entire left tree against the right
sub-tree of the right node.

\begin{figure}[htp!]
\centering
\begin{forest}
  [,phantom,tikz={
    \draw[Matching,color07] (!1) -- (!ll);
  },
    [→,fill=color07,
       tikz={
         \node[NodeLabel] at (.south east) {L};
       },
       [A,for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}},
       ]
       [D,for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}},
       ]
    ]
    [,phantom[,phantom]]
    [→,
       tikz={\node[NodeLabel] at (.south east) {R};},
       [B,for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}},
       ]
       [→,fill=color07,for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}},
          tikz={\node[NodeLabel] at (.south east) {R};},
         [A]
         [D]
       ]
    ]
  ]
\end{forest}
\\
\vspace{20pt}
$\delta(
\begin{forest}
  begin draw/.code={\begin{tikzpicture}[anchor=base,baseline]},
    [→,fill=color07,tikz={\node[NodeLabel] at (.south east) {L};},]
  \end{forest}
  ,
  \begin{forest}
    begin draw/.code={\begin{tikzpicture}[anchor=base,baseline]},
      [→,tikz={\node[NodeLabel] at (.south east) {R};},]
  \end{forest}
  )
= \out{
  \MathInsPi{B}{\_}
  {
    \textcolor{black}{\delta(
    \begin{forest}
      begin draw/.code={\begin{tikzpicture}[anchor=base,baseline]},
        [→,fill=color07,
           tikz={\node[NodeLabel] at (.south east) {L};},
           [A,for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}},]
           [D,for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}},]
        ]
    \end{forest}
    ,
    \begin{forest}
      begin draw/.code={\begin{tikzpicture}[anchor=base,baseline]},
       [→,fill=color07,
          tikz={\node[NodeLabel] at (.south east) {R};},
         [A,for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}},]
         [D,for tree={text opacity=0.2,draw opacity=0.2,edge={draw opacity=0.2}},]
       ]
    \end{forest}
    )}
  }
}
$
\caption{Run of the algorithm for turning a matching into a diff (example 3)}\label{chick-guess-to-diff-3}
\end{figure}

The final result of our algorithm on our running example is given in
Figure~\ref{chick-guess-result}

\begin{figure}[htp!]
\centering
\begin{forest}
[,phantom
  [→,fill=color06
    [→,fill=color07,
      [A,fill=color01]
      [→,fill=color08,
        [C,fill=color02]
        [D,fill=color03]
      ]
    ]
    [→,fill=color09,
      [A,fill=color12]
      [→,fill=color10,
        [C,fill=color13]
        [D,fill=color14]
      ]
    ]
  ]
  [,phantom[,phantom[,phantom]]]
  [→,fill=color06
    [→,fill=color08
      [C,fill=color02]
      [→,fill=color15
        [B]
        [→,fill=color07
          [A,fill=color01]
          [D,fill=color03]
        ]
      ]
    ]
    [→,fill=color09
      [A,fill=color12]
      [→,fill=color16
        [B]
        [→,fill=color10
          [C,fill=color13]
          [D,fill=color14]
        ]
      ]
    ]
  ]
]
\end{forest}
\\
\vspace{20pt}
\scalebox{1.5}{
  \tcbhighmath[size=fbox,boxrule=2pt,colframe=color06,colback=white]{
    \begin{tabular}{c}
      $
      \MathModPi%
      {
        \MathPermutePis%
        {[0,1]}
        {
          \tcbhighmath[size=fbox,boxrule=2pt,colframe=color08,colback=white]{
            \MathModPi%
            {
              \tcbhighmath[size=fbox,boxrule=2pt,colframe=color02,colback=white]{
                \MathSame{}
              }
            }
            {\MathSame{}}
            {
              \tcbhighmath[size=fbox,boxrule=2pt,colframe=color15,colback=white]{
                \MathInsPi%
                {B}
                {\_}
                {
                  \tcbhighmath[size=fbox,boxrule=2pt,colframe=color07,colback=white]{
                    \MathSame{}
                  }
                }
              }
            }
          }
        }
      }
      {\MathSame{}}
      {  } % left empty so that it can be on two lines
      $
      \tabularnewline
      $
        \tcbhighmath[size=fbox,boxrule=2pt,colframe=color09,colback=white]{
          \MathModPi%
          {
            \tcbhighmath[size=fbox,boxrule=2pt,colframe=color12,colback=white]{
              \MathSame{}
            }
          }
          {\MathSame{}}
          {
            \tcbhighmath[size=fbox,boxrule=2pt,colframe=color16,colback=white]{
              \MathInsPi%
              {B}
              {\_}
              {
                \tcbhighmath[size=fbox,boxrule=2pt,colframe=color10,colback=white]{
                  \MathSame{}
                }
              }
            }
          }
        }
      $
    \end{tabular}
  }
}
\caption{Final guess}\label{chick-guess-result}
\end{figure}


% \begin{tikzpicture}

%   \tikzstyle{ast} = [%
%   align=center,
%   draw=black,
%   font=\bfseries,
%   inner sep=10pt,
%   line width=3pt,
%   rectangle,
%   ultra thick,
%   ];

%   \tikzset{level distance=45pt};
%   \tikzset{edge from parent/.style=
%     {
%       draw,
%       edge from parent path={(\tikzparentnode.south)
%         -- +(0,-10pt)
%         -| (\tikzchildnode.north)},
%       ultra thick,
%     }
%   }

%   \Tree
%   [.\node[ast]{→};
%     [.\node[ast]{→};
%       [.\node[ast,fill=color01]{A}; ]
%       [.\node[ast]{→};
%         [.\node[ast,fill=color02]{C};]
%         [.\node[ast,fill=color03]{D};]
%       ]
%     ]
%     [.\node[ast]{→};
%       [.\node[ast,fill=color01]{A}; ]
%       [.\node[ast]{→};
%         [.\node[ast,fill=color02]{C};]
%         [.\node[ast,fill=color03]{D};]
%       ]
%     ]
%   ]

% \end{tikzpicture}
